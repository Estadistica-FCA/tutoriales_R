{
  "articles": [
    {
      "path": "about.html",
      "title": "Acerca de...",
      "author": [],
      "contents": "\n\nContents\nAgustín Alesso\nPatricia Acetta\n\nEste sitio fue preparado por el equipo de Estadística de la FCA.\nAgustín Alesso\nIngeniero Agrónomo (UNL) Dr. en Ciencias Agropecuarias (UNC) `fontawesome::fa(“email”) calesso@fca.unl.edu.ar\nProfesor Adjunto de la UNL. Orienta su investigación en métodos estadísticos y geoestadísticos aplicados a agricultura de precisión, y trabaja en temas relacionados con el análisis de la variabilidad espacial y temporal de rendimientos de cultivos y atributos de suelo y delimitación de zonas de manejo.\nPatricia Acetta\nIngeniera Agrónoma (UNL) Candidata a Mg Sc. en Negocios Agroalimentarios (UNL) pacetta@fca.unl.edu.ar\nAyudante de cátedra en grado, pregrado y posgrado de la UNL. Orienta su investigación en economía de la producción agropecuaria, análisis de datos de gestión económica y financiera y cambios tecnológicos de empresas agropecuarias, de tendencias de precios, en el impacto en la toma de decisiones en los agronegocios; formulación y evaluación de proyectos de desarrollo rural, con énfasis en alternativas no tradicionales.\n\n\n\n",
      "last_modified": "2022-03-14T07:26:10-03:00"
    },
    {
      "path": "como_crear_proyecto_rstudio.html",
      "title": "¿Cómo crear un proyecto en RStudio?",
      "author": [],
      "contents": "\n\nContents\n¿Qué es un Proyecto?\n¿Cómo crar un proyecto?\n\n¿Qué es un Proyecto?\nR trabaja con un directorio de trabajo o working directory que es la dirección o path que figura en el titulo del panel Console. Esto se puede averiguar con getwd()\n\n\ngetwd()\n\n\n\nPor defecto es el directorio base del usuario que depende de cada plataforma. En linux es el /home/usuario en cambio en Windows es C:/Users/usuario/Documents.\nA menos que se especifique lo contrario, se asume que los archivos de entrada o salida se ubican en esa. Esto se puede modificar en cualquier momento con la función setwd().\n\n\nsetwd(\"ruta/a/otra/carpeta\")\n\n\n\nRStudio extiende esta característica a través de los proyectos o projects. Cada proyecto es una carpeta o folder que contienen un archivo .RProj con algunas configuraciones específicas.\nAl abrir un proyecto, automáticamente se cambia el directorio de trabajo a esta carpeta. Esto permite organizar los archivos de datos, las salidas, los scripts, etc., dentro de un directorio de trabajo (working directory) y volver a ellos de manera más rápida, eficiente, y portable.\n¿Cómo crar un proyecto?\nPara crear un proyecto en RStudio:\nIr a File > New project... o bien el ícono Create project de la barra de herramientas.\n\n\n\nSeleccionar New Directory y en Project type seleccionar New project.\n\n\n\nUna vez en el cuadro de diálogo Create new project ingresar el nombre del proyecto (e.g. estadistica) en Directory name que será a su vez el nombre de la carpeta que RStudio va a crear por nosotros.\nLuego en Create project as a subdirectory of indicar donde queremos que RStudio cree la carpeta.\n\n\n\nSi todo sale bien, se crea la carpeta con el nombre que indicamos y dentro de ésta un archivo con extensión .Rproj. Este archivo solamente se usa para abrir el directorio. No se debe sobreescribir con el script.\n\n\n\n",
      "last_modified": "2022-03-14T07:26:11-03:00"
    },
    {
      "path": "como_importar_datos_en_R.html",
      "title": "¿Cómo importar datos en R?",
      "author": [],
      "contents": "\n\nContents\nDesde la consola (recomendado)\nDesde el importador de datos de RStudio\nVerificación de los datos\n\nUn aspecto importante para cualquier análisis de datos es acceder a los datos!! Éstos pueden estar almacenados en diversos formatos: archivos de texto (*.txt, *.dat, etc), texto separado por comas (*.csv), planillas de cálculos (*.xls o *.xlsx), etc.\nExisten diversas funciones que vienen por defecto en R o bien en paquetes específicos que permiten leer virtualmente cualquier formato de archivos. El paquete rio brinda una interfase unificada y simplificada para realizar esta tarea desde la consola. Otra alternativa es el modulo Import dataset de RStudio.\nA continuación veremos como cargar el archivo urbana_weather.xlsx que contiene datos meteorológicos de la ciudad de Urbana (IL).\nDesde la consola (recomendado)\nUna vez que descargamos el archivo datos en la carpeta data dentro de nuestro directorio de trabajo o proyecto podemos leerlo en R usando la función import() del paquete rio. Esta función se encargará de llamar la función necesaria para leer el archivo que le suministremos.\n\n\n# Cargar rio (si no estaba cargado antes)\npacman::p_load(rio)\n\n# importar los datos\nurbana <- import(\"./data/urbana_weather.xlsx\", setclass = \"tibble\")\nurbana\n\n\n# A tibble: 240 × 4\n    YEAR month precip  temp\n   <dbl> <chr>  <dbl> <dbl>\n 1  2000 Jan     1.54  25.6\n 2  2001 Jan     1.32  25.4\n 3  2002 Jan     2.81  34  \n 4  2003 Jan     0.79  21.1\n 5  2004 Jan     2.18  24  \n 6  2005 Jan     6.2   27.8\n 7  2006 Jan     1.78  37.8\n 8  2007 Jan     3.03  29.7\n 9  2008 Jan     2.31  26.2\n10  2009 Jan     0.68  18.8\n# … with 230 more rows\n\nEl argumento setClass permite especificar en que tipo de objeto importarlo. Por defecto es un data.frame. En este caso mostramos como indicar que queremos crear un objeto tipo tibble, que es un data.frame con anabólicos.\nSi sólo estuvieramos ineresados en el rango A1:C5 (primeros 4 registros de las 3 primeras columnas), podríamos usar:\n\n\nurbana2 <- import(file = \"./data/urbana_weather.xlsx\", range = \"A1:C5\")\nurbana2\n\n\n  YEAR month precip\n1 2000   Jan   1.54\n2 2001   Jan   1.32\n3 2002   Jan   2.81\n4 2003   Jan   0.79\n\nDesde el importador de datos de RStudio\nRStudio cuenta con un asistente de importación de datos (File > Import Dataset) que brinda interfase a varias funciones especializadas en la importación de datos de paquetes específicos como readr, readxl, etc.\nEn el menú File > Import Dataset o bien el ícono del panel Environment despliega una lista con disitintas opciones de importación: nos interesa From Excel (readxl)...\n\n\n\nFigure 1: Importador de datos\n\n\n\n\n\n\nFigure 2: Importador de datos\n\n\n\nEste menú tiene cuatro paneles:\nUna barra de direccion para indicar la ruta al archivo o URL.\nUna vista previa del contenido del archivo\nOpciones de importación: aquí se puede especificar el nombre del objeto que se creará dentro de R (Name), la cantidad de lineas a leer, el número de la hoja, el rango de celdas, líneas a saltear (skip) y el identificador de datos NA.\nVista previa del código. En esta parte se puede visualizar como se construye el comando que se ejecturará al clickear en Import.\n\nAclaración: es muy importante que el código generado por este asistente sea incluido en el script para futuras sesiones.\n\nVerificación de los datos\nUna vez importados los datos es conveniente verificar como han sido leidos en el R.\nComo vimos antes, una alternativa es imprimirlo escribiendo el nombre del objeto directamente en la consola.\n\n\nurbana\n\n\n# A tibble: 240 × 4\n    YEAR month precip  temp\n   <dbl> <chr>  <dbl> <dbl>\n 1  2000 Jan     1.54  25.6\n 2  2001 Jan     1.32  25.4\n 3  2002 Jan     2.81  34  \n 4  2003 Jan     0.79  21.1\n 5  2004 Jan     2.18  24  \n 6  2005 Jan     6.2   27.8\n 7  2006 Jan     1.78  37.8\n 8  2007 Jan     3.03  29.7\n 9  2008 Jan     2.31  26.2\n10  2009 Jan     0.68  18.8\n# … with 230 more rows\n\nOtra alternativa es utilizar la función View() que muestra la tabla de datos en un formato de planilla interactiva de solo lectura.\n\n\nView(urbana)\n\n\n\nSi bien podemos inferir que tipo de datos se leyeron, una alternativa mejor es mirar la estructura con la función str().\n\n\nstr(urbana)\n\n\ntibble [240 × 4] (S3: tbl_df/tbl/data.frame)\n $ YEAR  : num [1:240] 2000 2001 2002 2003 2004 ...\n $ month : chr [1:240] \"Jan\" \"Jan\" \"Jan\" \"Jan\" ...\n $ precip: num [1:240] 1.54 1.32 2.81 0.79 2.18 6.2 1.78 3.03 2.31 0.68 ...\n $ temp  : num [1:240] 25.6 25.4 34 21.1 24 27.8 37.8 29.7 26.2 18.8 ...\n\nEsto nos está diciendo que el objeto es un tibble donde cada columna es una variable y cada fila una observacion. En nuestro set de datos hay 4 variables (YEAR, month, precip and temp) y 240 observaciones. Junto con el nombre de cada variable hay una breve descripción del tipo de datos (int para integer, chr para character y num para numeric) y una vista previa de los primeros valores.\n\n\n\n",
      "last_modified": "2022-03-14T07:26:12-03:00"
    },
    {
      "path": "como_instalar_R_Rstudio.html",
      "title": "¿Cómo instalar R y RStudio?",
      "author": [],
      "contents": "\n\nContents\nInstalación de R\nInstalación de RStudio\n\nR y RStudio se instalan por separado. R puede funcionar sin RStudio, en cambio RStudio necesita que al menos una versión de R esté instalada en el sistema. Ambos softwares son multiplataforma y pueden ser ejecutados en sistemas operativos Windows, Mac OS X y Linux.\nEn las páginas https://cloud.r-project.org/ y https://www.rstudio.com/products/rstudio/download/ hay instrucciones específicas para cada plataforma.\n\n\n\nFigure 1: Página de descaga de R\n\n\n\n\n\n\nFigure 2: Página de descarga de RStudio\n\n\n\nA continuación se describe el procedimiento para instalar R y RStudio bajo Windows.\nInstalación de R\nDescargar el archivo instalador correspondiente a la última versión estable de R desde el CRAN1 (del inglés, Comprenhensive R Archive Network) visitando el siguiente link.\nEjecutar el archivo descargado 2 y seguir el asistente de instalación con todas las opciones por defecto.\nSi la instalación ha sido exitosa en el menú Inicio podrá encontrarse la carpeta R que contendrá dos accesos directos a la interfase de usuario mínima que viene con la versión de R para Windows.\n\n\n\nFigure 3: R GUI para Windows\n\n\n\nInstalación de RStudio\nDescargar el archivo de instalación correspondiente a nuestra plataforma o sistema operativo. Al momento de escribir estas instrucciones la última versión estable de RStudio era RStudio-2022.02.0-443.exe que se encuentra en este link\nEn el caso que haya una nueva versión, ir al sitio web de descarga de RStudio https://www.rstudio.com/products/rstudio/download/\n\n\n\nFigure 4: Página de descarga de RStudio\n\n\n\nEjecutar el archivo .exe y seguir el asistente de instalación con todas las opciones por defecto.\nSi la instalación ha sido exitosa en el menú Inicio dentro de la carpeta RStudio se encontrará el acceso directo a RStudio el cual, mediante el menu contextual (botón derecho del ratón) puede enviarse al Escritorio como acceso directo o bien anclar al menu de Inicio o barra de acceso rápido.\nAhora sí, ya tenemos listo R y RStudio para empezar a trabajar!!\n\nCRAN es un conjunto de servidores espejo distribuidos alrededor del mundo que tienen copias de R y sus paquetes. No es necesario escojer el espejo más cercano ya que el espejo nube (https://cloud.r-project.org) automáticamente determina de que servidor conviene realizar la descarga.↩︎\nAl momento de escribir estas instrucciones la última versión estable de R era la 4.1.1 “Kick Things”, por lo tanto el link apuntará al archivo R-4.1.3-win.exe.↩︎\n",
      "last_modified": "2022-03-14T07:26:13-03:00"
    },
    {
      "path": "como_instalar_y_cargar_paquetes.html",
      "title": "¿Cómo instalar y cargar paquetes en R?",
      "author": [],
      "contents": "\n\nContents\nAlternativa 1: install.packages()/library()\nAlternativa 2: pacman\nAlternativa 3: Panel Packages de RStudio\n¿library(), pacman o panel Packages?\n\nR es modular ya que consta de un núcleo básico de programas para realizar operaciones, gráficos y análisis. Estos programas vienen incluidos en el paquete de instalación. No obstante, existe un repositorio denominado CRAN (Comprehensive R Archive Network) donde constantemente se van agregando nuevos paquetes para expandir las funcionalidades de R.\n\nIMPORTANTE Para poder acceder a estos paquetes extra, primero es necesario instalarlos en nuestro sistema y luego, cuando los necesitemos, cargarlo en la sesión de trabajo.\n\nPara esto tenemos 3 alternativoas:\nFunciones install.packages()/library()\nPaquete pacman (recomendada)\nPanel Packages de RStudio\nA continuación se muestra un ejemplo para instalar los paquetes nortest y moments\nAlternativa 1: install.packages()/library()\nSi queremos instalar uno paquetes necesitamos correr por única vez la función install.packages() indicando el nombre del paquete entre comillas:\n\n\n# Un solo paquete\ninstall.packages(\"moments\")\n\n\n\nSi queremos instalar varios paquetes a la vez podemos crear un vector que contenga los nombres de los paquetes y usarlo como argumento en la función.\n\n\n# Varios paquetes\npaquetes <- c(\"nortest\", \"moments\")\ninstall.packages(paquetes)\n\n\n\nUna vez instalados, los paquetes se deben cargar en el entorno o sesión de trabajo usando la función library().\n\n\n# Cargar el paquerte agricolae\nlibrary(moments)\n\n\n\nA diferencia de install.packages(), la carga de los paquetes es individual, es decir, debejos ejecutar library() por cada paquete que querramos cargar.\nAlternativamente si queremos usar alguna función específica sin cargar el paquete entero podemos usar ::. Por ejemplo, lara usar la función skewness() del paquete moments podemos hacer\n\n\nmoments::skewness(x)\n\n\n\nSi por alguna circunstancia queremos removerlo del entorno de trabajo (no del sistemaa), es necesario usar la función detach()\n\n\n# Para remover el paquete moments\ndetach(\"package:moments\", unload = T)\n\n\n\nFinalmente si queremos desinstalarlo de nuestra máquina, es necesario usar la función remove.packages()\n\n\n# Para remover el paquete moments\nremove.packages(\"moments\")\n\n\n\nAlternativa 2: pacman\nEl proceso anterior se puede simplificar usando el paquete pacman. Pero primero hay que instalarlo por única vez usando install.packages():\n\n\ninstall.packages(\"pacman\")\n\n\n\nLuego, cuando queremos usar un paquete o varios paquetes podemos llamarlos usando p_load():\n\n\npacman::p_load(moments, nortest)  # no necesitamos usar comillas\n\n\n\nEsta función por defecto va a chequear si el o los paquetes indicados están instalados antes de cargarlos. Si algun paquete no está instalado, lo instala y después lo carga. Eso se controla con el argumento install = FALSE.\nPara chequear si un paquete esta cargado:\n\n\npacman::p_isloaded(x)\n\n\n\nPara remover un paquete de la sesion\n\n\npacman::p_unload(x)\n\n\n\nPara remover algun paquete de nuestra biblioteca\n\n\npacman::p_delete(x)\n\n\n\nPara buscar un paquete por el nombre, o alguna parte de él\n\n\npacman::p_search_library(\"tidy\")\n\n\n\nAlternativa 3: Panel Packages de RStudio\nRStudio cuenta con un panel desde donde podemos instalar y cargar paquetes. En ambos casos RStudio corre las funciones install.packages() y library().\n\n\n\nFigure 1: Panel Packages\n\n\n\nPara instalar por primera vez los paquetes se puede utilizar el ícono Install que abre el siguiente cuadro de diálogo.\n\n\n\nFigure 2: Cuadro de diálogo para instalar paquetes\n\n\n\nPor defecto, RStudio buscará e instalará los paquetes desde CRAN. En Packages hay que ingresar los nombres de los paquetes separados por comas. RStudio ofrece la posibilidad de ir completando el nombre si no nos acordamos.\nFinalmente, para cargar los paquetes podemos usar el panel Packages, buscar el paquete que queremos y tildar la casilla.\n¿library(), pacman o panel Packages?\nSi bien el panel Packages brinda una interfase para seleccionar y cargar los paquetes con un click, esta alternativa tiene una desventaja: hay que acordarse en futuras sesiones que es necesario cargar ese paquete. Es por eso que incluir un par de líneas en el script con la función library() o pacman::p_load()es mejor. pacman tiene la ventaja extra de chequear si el paquete está instalado o no.\n\n\n\n",
      "last_modified": "2022-03-14T07:26:16-03:00"
    },
    {
      "path": "index.html",
      "title": "Tutoriales de R",
      "author": [],
      "contents": "\n\n\n\nR es un lenguaje y entorno para el procesamiento, visualización y análisis estadístico de datos. Fue creado en 1993 por R. Gentleman y R. Ihaka, ambos científicos del Departamento de Estadística de la Universidad de Auckland (Nueva Zelanda). Actualmente su desarrollo y mantenimiento está a cargo del R Core Team. El sitio oficial del proyecto es www.r-project.org\n\n\n\nFigure 1: Página oficial de R Project\n\n\n\nHoy en día, R es la lingua franca del procesamiento y análisis de datos, tanto en el ámbito académico como comercial dado que es gratiuto, multiplataforma, de código abierto (open source, liberado con licencia GNU/GPL). Esto y el ecosistema de paquetes contribuidos por la comunidad de usuarios lo convierte en un software muy potente ya que expresa el estado del arte de los métodos estadísticos.\nLa flexibilidad y potencia de R se basa en su interfaz de comandos (CLI, del inglés command line interface ) que permite la ejecución de comandos de manera interactiva (en consola) o estructurada mediante scripts.\n\n\n\nFigure 2: Ejemplo de consola o terminal de Linux y Windows corriendo la última versión estable de R\n\n\n\nEsta característica impone una curva de aprendizaje lenta. Con el objetivo de acelerar el aprendizaje se ha diseñado este sitio web con orientado a estudiantes de Estadísica 1 y 2 de la carrera de Ingenieria Agronómica de la Facultad de Ciencias Agrarias (Universidad Nacional del Litoral).\n\n\n\n",
      "last_modified": "2022-03-14T07:26:17-03:00"
    },
    {
      "path": "introduccion_a_dplyr.html",
      "title": "¿Cómo manipular datos con `dplyr`?",
      "author": [],
      "contents": "\n\nContents\n¿Qué es dplyr?\n¿Cómo conseguir dplyr?\nVerbos importantes de dplyr para recordar\ndplyr en acción\n\n¿Qué es dplyr?\ndplyr es un paquete de R muy potente para la exploración, transformación y resumen de datos en formato de tabla con filas (observaciones) y columnas (variables). Es un componente de un conjunto de packages llamado tidyverse desarrollados por Hadley Wickham\nEl paquete contiene un conjunto de funciones (o verbos) que realizan operaciones comunes para el manejo de datos tales como: filtrar filas, seleccionar columnas, re-ordenar filas, agregar o transformar columnas, resumir datos. También permite agrupar los datos facilitando la estrategia split-apply-combine, es decir, dividir (split) los datos según una variable de grupo, aplicar (apply) alguna transformación o resumen y combinar (combine) las partes para presentar los resultados.\nSi bien R base tiene funciones que realizan las mismas tareas (split(), subset(), apply(), sapply(), lapply(), tapply() and aggregate()), el paquete dplyr brinda una interface más consistente que permite trabajar de manera más facil con data.frame (tabla de datos) más que con vectores.\n¿Cómo conseguir dplyr?\nPara instalar por primera vez en la computadora:\n\n\n# Solo\ninstall.packages(\"dplyr\")\n\n# O junto con la familia tidyverse\ninstall.packages(\"tidyverse\")\n\n\n\nLo anterior se debe realizar por única vez si el paquete no está previamente instalado en la máquina. Para usar las funciones en una sesion de trabajo hay que cargarlo con library():\n\n\n# Solo\nlibrary(\"dplyr\")\n\n# O junto con la familia tidyverse\nlibrary(\"tidyverse\")\n\n\n\nR va a avisarnos en la consola que esta enmascarando (reemplazando) algunas funciones que ya estaban en el entorno, o bien el paquete nos devuelve algun mensaje. A menos que diga Error ..., eso está bien.\nVerbos importantes de dplyr para recordar\nToda la estrategia de trabajo con datos de dplyr se basa en 6 verbos:\nverbo\ndescripción\nselect()\nselecciona columnas (variables)\nfilter()\nfiltra o selecciona las filas (observaciones)\narrange()\nre-ordena las filas\nmutate()\ncrea nuevas columnas o modifica las preexistentes\nsummarise()\nresumen los valores de una variable\ngroup_by()\npermite aplicar los verbos anteriores en subgrupos (split-apply-combine)\nsample_n()\npara tomar muestras aleatorias con o sin reposición\nEn la mayoría de los casos la sintaxis es:\nfunction(que_datos, que_hacer_con_los_datos)\nEn que_datos hay que poner el nombre del set de datos o data.frame (a menos que se use el operador %>% para encadenar, mas adelante) y en que_hacer_con_los_datos indicar que operación, condicion, transformacion, etc aplicar a las filas y columnas.\ndplyr en acción\nPara ilustrar el uso del paquete vamos a usar los datos contenidos en el archivo pesada_terneros.xlsx. Para más detalles ir a la hoja de descripción de datos.\n\n\n# Cargar los datos con readxl\nlibrary(readxl)\nterneros <- read_excel(\"./data/pesada_terneros.xlsx\")\n\n\n\nSeleccionando variables\nUna tareas básicas cuando se exploran datos es la selección de columnas de interés (variables). Esto se lleva a cabo con select().\nPara seleccionar las columnas Procedencia, IDV y Peso:\n\n\n# Sin asignar\nselect(terneros, Procedencia, IDV, Peso)\n\n\n# A tibble: 1,598 × 3\n   Procedencia IDV        Peso\n   <chr>       <chr>     <dbl>\n 1 La Rosita   NR047A202   204\n 2 La Rosita   GN685B267   186\n 3 La Rosita   AI101A751   182\n 4 La Rosita   TM603C877   186\n 5 La Rosita   TM420B797   186\n 6 La Rosita   LH837F500   208\n 7 La Rosita   NR047A217   170\n 8 La Rosita   LH837F508   188\n 9 La Rosita   GN685B256   172\n10 La Rosita   QW110A058   172\n# … with 1,588 more rows\n\n# Creando un nuevo set de datos\nmis_columnas <- select(terneros, Procedencia, IDV, Peso)\n\n\n\nPor defecto, si no se asigna a un nuevo objeto, el resultado de la operación se imprime en la consola con la función print() la cual por defecto muestra las 10 primeras observaciones y la cantidad de columnas que entran en la pantalla. Aquellas columnas que no entran son indicadas al pie.\nSi quiero ver más registros se puede usar el argumento n = de print()\n\n\nprint(mis_columnas, n = 15)\n\n\n# A tibble: 1,598 × 3\n   Procedencia IDV        Peso\n   <chr>       <chr>     <dbl>\n 1 La Rosita   NR047A202   204\n 2 La Rosita   GN685B267   186\n 3 La Rosita   AI101A751   182\n 4 La Rosita   TM603C877   186\n 5 La Rosita   TM420B797   186\n 6 La Rosita   LH837F500   208\n 7 La Rosita   NR047A217   170\n 8 La Rosita   LH837F508   188\n 9 La Rosita   GN685B256   172\n10 La Rosita   QW110A058   172\n11 La Rosita   LH837F497   188\n12 La Rosita   TM420B803   180\n13 La Rosita   LH837F514   198\n14 La Rosita   II641B940   200\n15 La Rosita   IY735C      242\n# … with 1,583 more rows\n\nCon n = \"all\" se imprimen todas (no se muestra por razones obvias)\nEl orden en que aparecen las variables en el resultado es el orden que se utilizó al seleccionarlas.\n\n\n# El orden altera el producto\nselect(terneros, Procedencia, IDV, Peso)\n\n\n# A tibble: 1,598 × 3\n   Procedencia IDV        Peso\n   <chr>       <chr>     <dbl>\n 1 La Rosita   NR047A202   204\n 2 La Rosita   GN685B267   186\n 3 La Rosita   AI101A751   182\n 4 La Rosita   TM603C877   186\n 5 La Rosita   TM420B797   186\n 6 La Rosita   LH837F500   208\n 7 La Rosita   NR047A217   170\n 8 La Rosita   LH837F508   188\n 9 La Rosita   GN685B256   172\n10 La Rosita   QW110A058   172\n# … with 1,588 more rows\n\nTambién se puede usar los comnados starts_with(), ends_with(), contains(), etc (ver ?select_helpers) para más opciones). Para elegir varias columnas que tienen un patron sin tener que tipear todos los nombres.\n\n\n# Selecciona columnas que empiezan con P\nselect(terneros, starts_with(\"P\"))\n\n\n# A tibble: 1,598 × 2\n   Procedencia  Peso\n   <chr>       <dbl>\n 1 La Rosita     204\n 2 La Rosita     186\n 3 La Rosita     182\n 4 La Rosita     186\n 5 La Rosita     186\n 6 La Rosita     208\n 7 La Rosita     170\n 8 La Rosita     188\n 9 La Rosita     172\n10 La Rosita     172\n# … with 1,588 more rows\n\nPara omitir algunas columnas en la seleccion se puede usar el - antes del nombre.\n\n\n# Selecciona columnas que empiezan con P\nselect(terneros, -IDV, -starts_with(\"P\"))\n\n\n# A tibble: 1,598 × 5\n   Sexo  `Fecha Ingreso`     Categoria Fecha              \n   <chr> <dttm>              <chr>     <dttm>             \n 1 Macho 2017-07-20 00:00:00 Ternero   2017-04-06 00:00:00\n 2 Macho 2017-07-20 00:00:00 Ternero   2017-04-06 00:00:00\n 3 Macho 2017-07-21 00:00:00 Ternero   2017-04-06 00:00:00\n 4 Macho 2017-07-20 00:00:00 Ternero   2017-04-06 00:00:00\n 5 Macho 2017-07-24 00:00:00 Ternero   2017-04-06 00:00:00\n 6 Macho 2017-07-24 00:00:00 Ternero   2017-04-06 00:00:00\n 7 Macho 2017-07-21 00:00:00 Ternero   2017-04-06 00:00:00\n 8 Macho 2017-07-24 00:00:00 Ternero   2017-04-06 00:00:00\n 9 Macho 2017-07-21 00:00:00 Ternero   2017-04-06 00:00:00\n10 Macho 2017-07-24 00:00:00 Ternero   2017-04-06 00:00:00\n# … with 1,588 more rows, and 1 more variable: Hora <dttm>\n\nSeleccionando observaciones\nOtra tarea muy frecuente es seleccionar casos o observaciones que cumplan con alguna condición. Esto se lleva a cabo con filter(). Se pueden usar los operadores booleanos ==, >, <, >=, <=, !=, %in%) para crear pruebas o condiciones lógicas.\nPara seleccionar los terneros de Los Corralitos:\n\n\n# Sin asignar\nfilter(terneros, Procedencia == 'Los Corralitos')\n\n\n# A tibble: 575 × 8\n   IDV       Procedencia    Sexo  `Fecha Ingreso`     Categoria\n   <chr>     <chr>          <chr> <dttm>              <chr>    \n 1 PO150A167 Los Corralitos Macho 2017-07-23 00:00:00 Ternero  \n 2 PO150A168 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 3 PO150A169 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 4 PO150A460 Los Corralitos Macho 2017-07-23 00:00:00 Ternero  \n 5 PO150A673 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 6 PO150A461 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 7 PO150A462 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 8 PO150A463 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 9 PO150A433 Los Corralitos Macho 2017-06-06 00:00:00 Ternero  \n10 PO150A434 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n# … with 565 more rows, and 3 more variables: Fecha <dttm>,\n#   Hora <dttm>, Peso <dbl>\n\n# Creando un nuevo set de datos\ncorralitos <- filter(terneros, Procedencia == 'Los Corralitos')\n\n\n\nLa seleccion se puede hacer por más de una condicion. Por ejemplo, seleccionar los de Los Corralitos que pesen más de 200 kg:\n\n\nfilter(terneros, Procedencia == 'Los Corralitos', Peso > 200)\n\n\n# A tibble: 260 × 8\n   IDV       Procedencia    Sexo  `Fecha Ingreso`     Categoria\n   <chr>     <chr>          <chr> <dttm>              <chr>    \n 1 PO150A167 Los Corralitos Macho 2017-07-23 00:00:00 Ternero  \n 2 PO150A168 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 3 PO150A169 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 4 PO150A673 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 5 PO150A462 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 6 PO150A463 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 7 PO150A434 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 8 PO150A435 Los Corralitos Macho 2017-07-23 00:00:00 Ternero  \n 9 PO150A675 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n10 PO150A681 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n# … with 250 more rows, and 3 more variables: Fecha <dttm>,\n#   Hora <dttm>, Peso <dbl>\n\nfilter() asume que cada condicion se debe cumplir en simultaneo para que la observación sea seleccionada. Esto equivale a utilizar el operador & (Y). En caso de querer seleccionar aquellos registros que cumple una u otra condicion se usa el operador | (O). Poniendo ! delante de la condicion se invierte la selección.\n\n\n# Operador &\nfilter(terneros, Procedencia == 'Los Corralitos' & Peso > 200)\n\n\n# A tibble: 260 × 8\n   IDV       Procedencia    Sexo  `Fecha Ingreso`     Categoria\n   <chr>     <chr>          <chr> <dttm>              <chr>    \n 1 PO150A167 Los Corralitos Macho 2017-07-23 00:00:00 Ternero  \n 2 PO150A168 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 3 PO150A169 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 4 PO150A673 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 5 PO150A462 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 6 PO150A463 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 7 PO150A434 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 8 PO150A435 Los Corralitos Macho 2017-07-23 00:00:00 Ternero  \n 9 PO150A675 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n10 PO150A681 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n# … with 250 more rows, and 3 more variables: Fecha <dttm>,\n#   Hora <dttm>, Peso <dbl>\n\n# Operador |\nfilter(terneros, Procedencia == 'Los Corralitos' | Peso > 200)\n\n\n# A tibble: 779 × 8\n   IDV       Procedencia  Sexo  `Fecha Ingreso`     Categoria\n   <chr>     <chr>        <chr> <dttm>              <chr>    \n 1 NR047A202 La Rosita    Macho 2017-07-20 00:00:00 Ternero  \n 2 LH837F500 La Rosita    Macho 2017-07-24 00:00:00 Ternero  \n 3 IY735C    La Rosita    Macho 2017-07-22 00:00:00 Ternero  \n 4 QW110A072 La Rosita    Macho 2017-07-24 00:00:00 Ternero  \n 5 LH837F526 La Rosita    Macho 2017-07-20 00:00:00 Ternero  \n 6 DS289A491 La Rosita    Macho 2017-07-24 00:00:00 Ternero  \n 7 TL698HK39 La Rosita    Macho 2017-07-20 00:00:00 Ternero  \n 8 LH837F538 La Rosita    Macho 2017-07-21 00:00:00 Ternero  \n 9 IW751A017 La Rosita    Macho 2017-07-24 00:00:00 Ternero  \n10 NO133A004 Las Glicinas Macho 2017-07-23 00:00:00 Ternero  \n# … with 769 more rows, and 3 more variables: Fecha <dttm>,\n#   Hora <dttm>, Peso <dbl>\n\nCon el operador %in% se puede especificar un rango de valores que deben cumplir. Por ejemplo terneros de Los Corralitos, Las Glicinas y Don Alberto\n\n\n# Indicando cada nombre\nfilter(terneros, Procedencia == 'Los Corralitos', Procedencia == 'Las Glicinas', Procedencia == 'Don Alberto')\n\n\n# A tibble: 0 × 8\n# … with 8 variables: IDV <chr>, Procedencia <chr>, Sexo <chr>,\n#   Fecha Ingreso <dttm>, Categoria <chr>, Fecha <dttm>, Hora <dttm>,\n#   Peso <dbl>\n\n# Más resumido con %in%\nfilter(terneros, Procedencia %in% c('Los Corralitos', 'Las Glicinas', 'Don Alberto'))\n\n\n# A tibble: 1,138 × 8\n   IDV       Procedencia  Sexo  `Fecha Ingreso`     Categoria\n   <chr>     <chr>        <chr> <dttm>              <chr>    \n 1 SZ208I507 Las Glicinas Macho 2017-07-20 00:00:00 Ternero  \n 2 SZ208H993 Las Glicinas Macho 2017-06-05 00:00:00 Ternero  \n 3 SZ208H849 Las Glicinas Macho 2017-06-05 00:00:00 Ternero  \n 4 SZ208H777 Las Glicinas Macho 2017-06-05 00:00:00 Ternero  \n 5 GT542A562 Las Glicinas Macho 2017-07-21 00:00:00 Ternero  \n 6 OQ152A550 Las Glicinas Macho 2017-07-21 00:00:00 Ternero  \n 7 NO133A057 Las Glicinas Macho 2017-07-24 00:00:00 Ternero  \n 8 SZ208H888 Las Glicinas Macho 2017-07-22 00:00:00 Ternero  \n 9 OQ152A566 Las Glicinas Macho 2017-07-20 00:00:00 Ternero  \n10 NO133A047 Las Glicinas Macho 2017-07-20 00:00:00 Ternero  \n# … with 1,128 more rows, and 3 more variables: Fecha <dttm>,\n#   Hora <dttm>, Peso <dbl>\n\nEncadenando operaciones (operador %>%)\ndplyr importa el operador %>% de otro paquete llamado magrittr. Este operador permite encadenar operaciones realizadas con los verbos. De este modo no hay que ir creando tablas intermedias o anidar funciones. El operador traduce como luego y se le de izquierda a derecha y se puede.\nEjemplo: Reportar los IDV y peso de los terneros con más de 250 kg. Esto implicaría seleccionar las columnas de interés y luego filtrar la tabla o vice versa.\n\n\n# Creando tablas intermedias\nterneros2 <- select(terneros, IDV, Peso)\nterneros2\n\n\n# A tibble: 1,598 × 2\n   IDV        Peso\n   <chr>     <dbl>\n 1 NR047A202   204\n 2 GN685B267   186\n 3 AI101A751   182\n 4 TM603C877   186\n 5 TM420B797   186\n 6 LH837F500   208\n 7 NR047A217   170\n 8 LH837F508   188\n 9 GN685B256   172\n10 QW110A058   172\n# … with 1,588 more rows\n\nterneros2 <- filter(terneros2, Peso > 250)\nterneros2\n\n\n# A tibble: 75 × 2\n   IDV        Peso\n   <chr>     <dbl>\n 1 NO133A004   258\n 2 OQ152A456   258\n 3 NO133A006   256\n 4 OQ152A553   256\n 5 PO150A166   290\n 6 PO150A674   256\n 7 PO150A656   272\n 8 NO133A045   264\n 9 PO150A571   264\n10 PO150A686   262\n# … with 65 more rows\n\n# Anidando\nfilter(select(terneros, IDV, Peso), Peso > 250)\n\n\n# A tibble: 75 × 2\n   IDV        Peso\n   <chr>     <dbl>\n 1 NO133A004   258\n 2 OQ152A456   258\n 3 NO133A006   256\n 4 OQ152A553   256\n 5 PO150A166   290\n 6 PO150A674   256\n 7 PO150A656   272\n 8 NO133A045   264\n 9 PO150A571   264\n10 PO150A686   262\n# … with 65 more rows\n\n# Usando %>%\nterneros %>%\n  select(IDV, Peso) %>%\n  filter(Peso >  250)\n\n\n# A tibble: 75 × 2\n   IDV        Peso\n   <chr>     <dbl>\n 1 NO133A004   258\n 2 OQ152A456   258\n 3 NO133A006   256\n 4 OQ152A553   256\n 5 PO150A166   290\n 6 PO150A674   256\n 7 PO150A656   272\n 8 NO133A045   264\n 9 PO150A571   264\n10 PO150A686   262\n# … with 65 more rows\n\nCon %>% se puede omitir el nombre de la tabla sobre la que se está trabajando (bonus: menos tipeo).\nLa última opción se lee: _tomar la tabla terneros, luego seleccionar las columnas IDV y Peso, luego filtrar los terneros con pesos mayores a 250 kg.\nEl operador de encadenamiento es muy útil cuando se encadenan muchas operaciones.\nOrdenar las filas\nPara ordenar según algun criterio aplicado a las columnas se usa arrange(). Por ejemplo, continuar con lo anterior pero mostrar ordenadospor peso.\n\n\n# Ordenar de menor a mayor\nterneros %>%\n  select(IDV, Peso) %>%\n  filter(Peso >  250) %>%\n  arrange(Peso)\n\n\n# A tibble: 75 × 2\n   IDV        Peso\n   <chr>     <dbl>\n 1 PO150A546   252\n 2 NS509H081   252\n 3 PO15A710    252\n 4 NO133A019   254\n 5 PO150A784   254\n 6 IA671B182   254\n 7 IA671B176   254\n 8 PO150A716   254\n 9 NO133A006   256\n10 OQ152A553   256\n# … with 65 more rows\n\nCon decs(variable) se ordena de mayor a menor\n\n\n# Ordenar de mayor a menor\nterneros %>%\n  select(IDV, Peso) %>%\n  filter(Peso >  250) %>%\n  arrange(desc(Peso))\n\n\n# A tibble: 75 × 2\n   IDV        Peso\n   <chr>     <dbl>\n 1 PO150A679   304\n 2 IA671B041   294\n 3 MM429A932   292\n 4 PO150A166   290\n 5 PO150A763   288\n 6 IA671B106   288\n 7 NS509G964   286\n 8 PO150A821   284\n 9 IA671B045   282\n10 NO133A000   280\n# … with 65 more rows\n\nCrear o transformar columnas\nPara crear nuevas columnas aplicando funciones a otras, o bien para transformar columnas se usa mutate(). Se pueden modificar más de una columna a la vez. Por ejemplo, suponiendo que interesa obtener el logaritmo natura de los pesos o elevar los pesos al cuadrado.\n\n\nterneros %>% \n  mutate(log_peso = log(Peso), peso2 = Peso**2) %>%\n  select(Peso, log_peso, peso2)                        # para que se vea mejor el resultado \n\n\n# A tibble: 1,598 × 3\n    Peso log_peso peso2\n   <dbl>    <dbl> <dbl>\n 1   204     5.32 41616\n 2   186     5.23 34596\n 3   182     5.20 33124\n 4   186     5.23 34596\n 5   186     5.23 34596\n 6   208     5.34 43264\n 7   170     5.14 28900\n 8   188     5.24 35344\n 9   172     5.15 29584\n10   172     5.15 29584\n# … with 1,588 more rows\n\nEsto no cambia el set de datos terneros ya que no se lo asignó a ningun objeto. Para sobreescribir o actualiza el set de datos terneros hay que asignarlo al mismo objeto.\n\n\nterneros <- terneros %>% \n  mutate(log_peso = log(Peso), peso2 = Peso**2)\n\n\n\nAclaración: Si se hubiese usado select() el set de datos terneros solamente contendría las columnas seleccionadas.\nOtro ejemplo más útil: calcular los z-scores de los peso (para ello se requiere calcular el promedio y desvio) y crear una columna que indique si es un outlier y luego reportar los que son outliers.\n\n\nterneros %>% \n  mutate(z = (Peso - mean(Peso))/sd(Peso), outlier = ifelse(abs(z) > 3, \"si\", \"no\")) %>%\n  filter(outlier == \"si\") %>%\n  select(IDV)\n\n\n# A tibble: 2 × 1\n  IDV      \n  <chr>    \n1 PO150A679\n2 IA671B041\n\nResmuir datos\nMediante summarise() se pueden aplicar funciones para resumir en un solo valor los valores de las columnas. Las funciones a aplicar deben devolver un único valor, por ejemplo mean(). Si usamos summary() esto devolverá 6 valores y dará error.\n\n\nterneros %>%\n  summarise(media = mean(Peso), sd = sd(Peso), n = n(), suma = sum(Peso), procedencias = n_distinct(Procedencia))\n\n\n# A tibble: 1 × 5\n  media    sd     n   suma procedencias\n  <dbl> <dbl> <int>  <dbl>        <int>\n1  183.  37.0  1598 291802            7\n\nNuevamente estos resultados pueden asignarse a otro objeto o bien encadenarse con otras operaciones.\nOtro ejemplo, obtener la cantidad de terneros de cada procedencia\n\n\nterneros %>%\n  count(Procedencia)\n\n\n# A tibble: 7 × 2\n  Procedencia        n\n  <chr>          <int>\n1 Don Alberto       69\n2 La Alameda       201\n3 La Estrella      118\n4 La Rosita         98\n5 La Segunda        43\n6 Las Glicinas     494\n7 Los Corralitos   575\n\nOtro ejemplo más, cantidad de terneros de cada procedencia separados en mayor o menor a 200 kg\n\n\nterneros %>%\n  count(Procedencia, Peso > 200)\n\n\n# A tibble: 14 × 3\n   Procedencia    `Peso > 200`     n\n   <chr>          <lgl>        <int>\n 1 Don Alberto    FALSE           49\n 2 Don Alberto    TRUE            20\n 3 La Alameda     FALSE          136\n 4 La Alameda     TRUE            65\n 5 La Estrella    FALSE          112\n 6 La Estrella    TRUE             6\n 7 La Rosita      FALSE           89\n 8 La Rosita      TRUE             9\n 9 La Segunda     FALSE            5\n10 La Segunda     TRUE            38\n11 Las Glicinas   FALSE          428\n12 Las Glicinas   TRUE            66\n13 Los Corralitos FALSE          315\n14 Los Corralitos TRUE           260\n\nAgrupar (último pero no menos importante)\nEl verbo group_by() es muy útil para aplicar operaciones en subgrupos y presentar todo junto (split-apply-combine). Lo que hace es indicar que en el data.frame hay una o más variables que conforman los grupos. Luego cada operación se aplica a esos subgrupos.\nEjemplo: calcular media, desvio, n y suma para cada procedencia.\n\n\nterneros %>%\n  group_by(Procedencia) %>%\n  summarise(media = mean(Peso), sd = sd(Peso), n = n(), suma = sum(Peso))\n\n\n# A tibble: 7 × 5\n  Procedencia    media    sd     n   suma\n  <chr>          <dbl> <dbl> <int>  <dbl>\n1 Don Alberto     179.  26.9    69  12354\n2 La Alameda      190.  39.5   201  38192\n3 La Estrella     179.  14.2   118  21138\n4 La Rosita       180.  17.4    98  17620\n5 La Segunda      229.  24.8    43   9868\n6 Las Glicinas    160.  33.7   494  79254\n7 Los Corralitos  197.  35.2   575 113376\n\nMuestrear\nEl verbo sample_n() and sample_frac() son útiles para tomar muestras aleatorias (con o sin reposición) de un conjunto de observaciones. También se puede hacer por subgrupo!\n\n\n# Una muestra de 50 novillos\nmuestra50 <- terneros %>%\n  sample_n(50)\nmuestra50\n\n\n# A tibble: 50 × 10\n   IDV       Procedencia    Sexo  `Fecha Ingreso`     Categoria\n   <chr>     <chr>          <chr> <dttm>              <chr>    \n 1 PO150A764 Los Corralitos Macho 2017-07-20 00:00:00 Ternero  \n 2 SZ208H756 Las Glicinas   Macho 2017-07-20 00:00:00 Ternero  \n 3 NO133A053 Las Glicinas   Macho 2017-07-23 00:00:00 Ternero  \n 4 PO150A463 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 5 SZ208H744 Las Glicinas   Macho 2017-07-21 00:00:00 Ternero  \n 6 NS509H021 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \n 7 SZ208H735 Las Glicinas   Macho 2017-07-21 00:00:00 Ternero  \n 8 GT542A662 Las Glicinas   Macho 2017-07-21 00:00:00 Ternero  \n 9 SZ208H865 Las Glicinas   Macho 2017-07-20 00:00:00 Ternero  \n10 SZ208H818 Las Glicinas   Macho 2017-07-24 00:00:00 Ternero  \n# … with 40 more rows, and 5 more variables: Fecha <dttm>,\n#   Hora <dttm>, Peso <dbl>, log_peso <dbl>, peso2 <dbl>\n\n# Una muestra de 10 novillos de cada procedencia\nmuestra_procedencia <- terneros %>%\n  group_by(Procedencia) %>%\n  sample_n(10)\nmuestra_procedencia\n\n\n# A tibble: 70 × 10\n# Groups:   Procedencia [7]\n   IDV       Procedencia Sexo  `Fecha Ingreso`     Categoria\n   <chr>     <chr>       <chr> <dttm>              <chr>    \n 1 GH738B351 Don Alberto Macho 2017-06-16 00:00:00 Ternero  \n 2 GH738B383 Don Alberto Macho 2017-06-16 00:00:00 Ternero  \n 3 GH738B326 Don Alberto Macho 2017-07-20 00:00:00 Ternero  \n 4 GH738B348 Don Alberto Macho 2017-07-23 00:00:00 Ternero  \n 5 GH738B372 Don Alberto Macho 2017-07-24 00:00:00 Ternero  \n 6 GH738B350 Don Alberto Macho 2017-07-22 00:00:00 Ternero  \n 7 GH738B347 Don Alberto Macho 2017-07-23 00:00:00 Ternero  \n 8 GH738B343 Don Alberto Macho 2017-06-16 00:00:00 Ternero  \n 9 GH738B381 Don Alberto Macho 2017-07-22 00:00:00 Ternero  \n10 GH738B332 Don Alberto Macho 2017-07-23 00:00:00 Ternero  \n# … with 60 more rows, and 5 more variables: Fecha <dttm>,\n#   Hora <dttm>, Peso <dbl>, log_peso <dbl>, peso2 <dbl>\n\n\n\n\n",
      "last_modified": "2022-03-14T07:26:21-03:00"
    },
    {
      "path": "introduccion_a_ggplot2.html",
      "title": "¿Cómo visualizar datos con `ggplot2`?",
      "author": [],
      "contents": "\n\nContents\n¿Cómo conseguir ggplot2?\nComponentes del gráfico en ggplot2\nPrimer gráfico paso a paso\nGráficos condicionales o por paneles: facets\nTemas\n\nR tiene por defecto el paquete graphics, también conocido como base plot system, que provee la función genérica plot() para hacer gráficos simples, y otras funciones para gráficos específicos (hist(), barplot(), boxplot(), etc).\nUsa un enfoque de papel y lapiz por capas donde el gráfico final es una sumatoria de capas que se agregan una a la vez sin posibilidad de modificarse luego. Generalmente es OK para gráficos simples o exploratorios. Para gráficos más complejos (con subgrupos o multipanel) requiere programar más. Una desventaja es la sintaxis poco consistente.\nEl paquete ggplot2, desarrollado por Hadley Wickham, está basado en la filosofía Gramática de gráficos ( grammar of graphics , por eso gg). Combina los dos enfoques: por capas y función.\nUno provee los datos, indica que variables asignar a las estéticas (ejes, escalas, colores, símbolos) y las geometrías o formas que se quieren graficar y ggplot2 se encarga del resto. Se puede ir agregando capas. Es muy potente para la exploración y visualización de datos en formato de tabla con filas (observaciones) y columnas (variables).\n¿Cómo conseguir ggplot2?\nPara instalarlo por primera vez en la computadora tenemos las siguientes alternativas:\n\n\n# Sólamente el paquete ggplot2\ninstall.packages(\"ggplot2\")\n\n# O junto con la familia tidyverse\ninstall.packages(\"tidyverse\")\n\n\n\nLo anterior se debe realizar por única vez si el paquete no está previamente instalado en la máquina. Para usar las funciones en una sesion de trabajo hay que cargarlo con library():\n\n\n# Solo\nlibrary(\"ggplot2\")\n\n# O junto con la familia tidyverse\nlibrary(\"tidyverse\")\n\n\n\n\n\nlibrary(\"ggplot2\")\n\n\n\nR va a avisarnos en la consola que esta enmascarando (reemplazando) algunas funciones que ya estaban en el entorno, o bien el paquete nos devuelve algun mensaje. A menos que diga Error ..., eso está bien.\nComponentes del gráfico en ggplot2\nggplot2 implementa una variante por capas de este paradigma gramática de gráficos de Leland Wilkinson (gg es por grammar of graphics). Como resultado, se crean una serie de capas que permiten describir y construir visualizaciones de manera estructurada en cuanto a representación de los elementos pero a su vez flexible para generar combinaciones nuevas.\nUn gráfico se define por la combinación de capas (layers), escalas (scales), coordenadas (coords) y facetas (facets). Adicionalmente a estos componentes se pueden aplicar temas (themes) que permiten controlar los detalles del diseño de la visualización.\nLayers\nLos layer se construyen con las funciones geom_* y stat_* que veremos más adelante. Constan de 5 elementos:\ndata, set de datos (data.frame o similar) que contiene la información que se desea visualizar.\nmapping, elementos de mapeo definidos mediante aes() para indicar la forma en que la las variables y observaciones van a ser representadas en la visualización mediante atributos estéticos (ejes, lineas, colores, rellenos, etc).\nstat, funciones estadísticas que resumen los datos aplicando funciones estadísticas, e.g. promedio, agrupamiento y conteo de observaciones, o ajuste de un modelo lineal o suavizado, etc.\ngeom, geometrías o formas que representan lo que realmente se ve en un gráfico: puntos, líneas, polígonos, etc.\nposition, ajuste de posición de los elementos geoms dentro de un layer para evitar su superposición.\nGeneralmente, sobre todo para gráficos simples, data y mapping se definen una vez para todo el gráfico dentro de la función ggplot(). En otras situaciones se hace a nivel de cada layer.\nScales\nAsignan los valores del espacio de datos a valores en el espacio de los elementos estéticos (aesthetics o aes). Por ejemplo, el uso de un color, forma o tamaño de en un geom puede ser controlado por un atributo de los datos. Las escalas también definen las leyenda y los ejes.\nCoordenadas\nSistema de coordendas (coord) que define que variables definiran el espacio del gráfico y como se representarán, e.g. coordanedas cartesianas, polares, etc.\nPaneles (facets)\nEs un elemento que permite especificar una o más variables para dividir el gráfico en paneles y así mostrar subgrupos de datos. Esto permite ver visualizar relaciones condicionales entre variables, e.g. y ~ x | z, es decir, que pasa con la variable x e y cuando cambia z.\nTemas\nAdicionalmente a estos componentes se pueden aplicar temas (themes) que permiten controlar los detalles del desieño de la visualización, tipografía, posición de algunos objetos, paleta de colores, etc. Los valores predeterminados de ggplot2 son un buen punto de partida pero exiten opciones predefinidas que pueden modificarse para generar un tema particular. Otra fuente para consultar es el trabajo de Tufte\nPrimer gráfico paso a paso\nVeamos con un ejemplo como se combinan los componentes anteriormente vistos para realizar un gráfico simple. Para esto vamos a usar el set de datos pesada_novillos.xlsx\n\n\nnovillos <- readxl::read_excel(\"data/pesada_novillos.xlsx\")\n\n\n\nNuestro primer gráfico tendrá como objetivo mostrar la relación que existe entre Peso_anterior y Peso (actual), y potencialmente ver si ésta es similar entre procedencias. Veamos paso por paso como se construye el gráfico.\nPrimero definimos el set de datos que usaremos:\n\n\nggplot(data = novillos)\n\n\n\n\nComo vemos esto no produjo nada ya que no indicamos cuales son las variables que queremos graficar y cómo graficarlas. Nuestro layer solo tiene la información de data. Agreguemos ahora la información de mappping usando aes(). Usando el operador + podemos concatenarlo al comando anterior.\n\n\nggplot(data = novillos) +\n  aes(x = Peso_inicial, y = Peso)\n\n\n\n\nAquí vemos que, si bien no hemos graficado nada, la información suministrada permite a ggplot identificar los ejes, definir el espacio de coordanadas (cartesianas por defecto) y proponer unos límites en función del rango de valores. Agreguemos ahora la geometría: en este caso tiene sentido usar geom_point() ya que queremos mostrar un punto por observación\n\n\nggplot(data = novillos) +\n  aes(x = Peso_anterior, y = Peso) +\n  geom_point()\n\n\n\n\nComo vemos ahora el gráfico va tomando forma. Este tipo de gráficos se llama gráfico de dispersión y muestra la relación entre ambas variables. Por defecto no se aplica ninguna transformación estadística lo que equivale a (stat = \"identity\").\nA este gráfico vamos a agregarle alguna función que permita resumir la relación entre ambas variables, por ejemplo un modelo de regresión. La mejor forma de representarlo sería una línea. Para eso vamos a agregar otro layer con geom_line() donde indicaremos una transformación de los datos stat = smooth.\n\n\nggplot(data = novillos) +\n  aes(x = Peso_anterior, y = Peso) +\n  geom_point() +\n  geom_line(stat = 'smooth', method = 'lm')\n\n\n\n\nHay una relación positiva para todo el set de datos pero puede enmascarar algun patrón por Procedencia. Esta información la podemos agregar con otros atributos estéticos como por ejemplo color:\n\n\nggplot(data = novillos) +\n  aes(x = Peso_anterior, y = Peso, color = Procedencia) +\n  geom_point() +\n  geom_line(stat = 'smooth', method = 'lm')\n\n\n\n\nDe este gráfico surge que la relación en todos los casos es positiva pero varia un poco según procedencia.\nDependiendo el tipo de geom tenemos distintos atributos estéticos para explorar: color y alpha (transparencia) para todos, shape y size para puntos, linewidth y linetype para lineas, y fill para barras, etc. Que tipo de atributo estético depende también de la naturaleza de la variable: continua o discreta. Veamos como queda mapear los valores de Procedencia al atributo shape (forma):\n\n\nggplot(data = novillos) +\n  aes(x = Peso_anterior, y = Peso, shape = Procedencia) +\n  geom_point() +\n  geom_line(stat = 'smooth', method = 'lm')\n\n\n\n\nLas estéticas se pueden combinar para mostrar mas relaciones entre variables. Por ejemplo, además de shape = Procedencia podríamos agregar la información de los pesos iniciales como color:\n\n\nggplot(data = novillos) +\n  aes(x = Peso_anterior, y = Peso, shape = Procedencia, \n      color = Peso_inicial) +\n  geom_point() +\n  geom_line(aes(group = Procedencia), stat = \"smooth\", method = \"lm\")\n\n\n\n\nClaramente esto es una exageración pero muestra la potencialiadad de ggplot2. Siempre tener en cuenta balance entre simplicidad del gráfico y la cantidad de información que queremos comunicar.\nFinalmente vamos a ver como mejorar los nombres de los ejes, leyendas y agregar un título. Esto lo hacemos con labs(). Tambien agregamos algun tema predefinido ocomo theme_bw().\n\n\nggplot(data = novillos) +\n  aes(x = Peso_anterior, y = Peso, color = Procedencia) +\n  geom_point() +\n  geom_line(stat = \"smooth\", method = \"lm\") +\n  labs(x = \"Peso anterior (kg)\", y = \"Peso actual (kg)\",\n       color = \"Procedencia\", title = \"Relación peso anterior y actual\") +\n  theme_bw()\n\n\n\n\nGráficos condicionales o por paneles: facets\nA veces es util mostrar los subgrupos en gráficos individuales o paneles. Esto se hace facilmente usando una o más variables condicionales con facets. Este tipo de gráficos también se denomian graficos condicionales ya que muestran la relacion de al menos dos variables de interés a través de los niveles de una tercera variable: y ~ x | z.\nPor ejemplo, en el primer gráfico vimos como mostrar la relación entre los pesos y las procedencias como color. Eventualmente, ese gráfico podria dividirse en 4 paneles (uno por procedencia) y mostrar en cada uno el subconjunto de puntos.\n\n\nggplot(data = novillos) +\n  aes(x = Peso_anterior, y = Peso) +\n  geom_point() +\n  geom_line(stat = 'smooth', method = 'lm') +\n  facet_wrap(~ Procedencia)\n\n\n\n\nHay dos tipos de facetado: facet_wrap() y facet_grid(). El primero permite agregar una o mas variables condicionales pero cada subpanel se muestra secuencialmente. Funciona bien cuando tenemos una sola variable para dividir los subplots o pocos niveles en la combinación. La forma de indicar la variable es ~ variable.\nEn cambio, facet_grid() permite organizar los subplots en filas y columnas. Las varialbes se indican en este orden fila ~ columna. Para este ejemplo vamos a usar la variable Tropa:\n\n\nggplot(data = novillos) +\n  aes(x = Peso_anterior, y = Peso) +\n  geom_point() +\n  geom_line(stat = 'smooth', method = 'lm') +\n  facet_grid(Tropa ~ Procedencia)\n\n\n\n\nPor defecto los subplots o facets tienen escalas iguales en ambos ejes para comparar. A veces conviene dejar una o las dos escalas variar libremente, esto se hace con el argumento scales y las palabras clave 'free_y', 'free_x' o 'free' (ambas a la vez).\n\n\nggplot(data = novillos) +\n  aes(x = Peso_anterior, y = Peso) +\n  geom_point() +\n  geom_line(stat = 'smooth', method = 'lm') +\n  facet_grid(Tropa ~ Procedencia, scales = \"free\")\n\n\n\n\nOtra aspecto importante en la visualización usando facets es el texto que identifica cada panales. Esto depende de como estan configurados los datos y se controla con el argument labeller. Por defecto se toma el valor del factor que se usa para definir los grupos. En algunos casos conviene incluir el nombres de la variable.\n\n\nggplot(data = novillos) +\n  aes(x = Peso_anterior, y = Peso) +\n  geom_point() +\n  geom_line(stat = 'smooth', method = 'lm') +\n  facet_grid(Tropa ~ Procedencia, scales = \"free\", labeller = label_both)\n\n\n\n\nTemas\nLos temas en ggplot hacen referencia al control fino de la posición, el aspecto, y las formas de los distintos componentes del gráfico. El listado de componentes que se pueden modificar en un tema se incluyen en ?theme(). Como vemos la lista es larga ya que cada aspecto del gráfico puede controlarse permitiendo crear nuestros propios temas.\nggplot2 algunos temas predefinidos. Por defecto los gráficos utilizan un tema llamado theme_gray() que tiene una seleccion de parámetros elegante y que sirve para la mayoría de los casos. Existen otros temas específicos que puden ser un punto de partida para hacer modificaciones extra.\nPor ejemplo, el tema them_bw() remueve el fondo gris pero si queremos quitar la grilla podemos hacer:\n\n\n# Modificar el tema\nmi_tema <- theme_bw() + theme(panel.grid = element_blank())\n\n# Aplicar nuestro nuevo tema.\nggplot(data = novillos) +\n  aes(x = Peso_anterior, y = Peso, color = Procedencia) +\n  geom_point() +\n  geom_line(stat = 'smooth', method = 'lm') +\n  mi_tema\n\n\n\n\n\n\n\n",
      "last_modified": "2022-03-14T07:26:26-03:00"
    },
    {
      "path": "primera_sesion.html",
      "title": "Primera sesion en R y RStudio",
      "author": [],
      "contents": "\n\nContents\nLa consola\nEl script\nAyuda!!!\n\nEl entorno de trabajo de RStudio se divide en cuatro paneles. La disposición y contenido de los 4 paneles se puede personalizar yendo a View > Panes > Panes Layout.... A continuación la descripción de los paneles por defecto.\n\n\n\nFigure 1: Interfase principal de RStudio\n\n\n\nEditor. Es donde se editan los scripts que son archivos de texto plano con los comandos para ejecutar en R. Este panel no aparece a menos que se cree un nuevo script o se abra uno previamente guardado.\nConsole (consola). Es donde vive R propiamente dicho. Allí se ejecutan los comandos y se obtienen las salidas de R.\nEnvironmnet/History/Connections. En la primera pestaña se visualizan los objetos (variables, funciones o datos cargados) que están disponibles en el entorno de R, i.e. en la memoria. En la segunda se puede ver el historial de comandos ingresados o enviados a la consola. La tercera pestaña visualiza las conexiones establecidas con diferentes base de datos.\nFiles/Plots/Packages/Help/Viewer. Allí se puede manejar los archivos del directorio de trabajo, visualizar los gráficos generados en R con posibilidad de exportarlos en varios formatos, administrar los paquetes o complementos, buscar o explorar el manual de ayuda y previsualizar archivos HTML.\nLa consola\nLa línea de comandos o consola es el modo interactivo mediante el cual podemos ejecutar comandos directamente en el intérprete de R. El símbolo o prompt > indica que R está disponible esperando una orden. Si la orden no está completa el símbolo se transforma en +. Por ejemplo: si tipeamos 2 + 2 y luego ENTER:\n\n\n2 + 2\n\n\n[1] 4\n\nObetenemos inmediatemente el resultado. Otro ejemplo: el promedio de los números 1, 3 y 4\n\n\n(1 + 3 + 4) / 3\n\n\n[1] 2.666667\n\nEl script\nEl editor de scripts (panel #1) es un editor de texto plano que está conectado con la consola (panel #2). Tiene algunas funcionalidades que facilitan la edición del código:\nResaltado sintaxis: mediante colores resalta las funciones, variables, comandos o palabras claves del lenguaje R\nSangrado automático: agrega espacios en blanco para mantener la sangría de los bloques de código.\nPlegado de código: permite colapsar bloques de código\nCompletado automático y ayuda en linea: muestra sugerencias para completar el comando o argumentos usando la tecla TAB.\nPara crear un nuevo script se puede usar uno de los siguientes métodos:\nIr a al menu File > New File > R Script\nUsar el atajo de teclado CTRL + SHIFT + N\nClickear en el primer ícono de la barra de menu\n\n\n\nFigure 2: Barra de herramientas de RStudio\n\n\n\nUna vez abierto el script en blanco, se pueden empezar a escribir los comandos de R. Por ejemplo podemos escribir lo siguiente:\n\n\n\"Hola Mundo!\" # Clásico mensaje \"Hola mundo!\"\n\n# Calcular el promedio de estos números\n(1 + 3 + 4) / 3\n\n\n\nEstos comandos no se van a ejecutar automáticamente ya que solo los hemos escritor en el script. Para ejecutar estos comandos en la consola hay que posicionar le cursor en la linea deseada o bien seleccionar si queremos ejecutar varias a la vez y luego enviarlo a la consoloa con una de las siguientes opciones:\nIr al menu Code > Run Selected Line(s)\nUsar el atajo de teclado CTRL + ENTER o CTRL + R\nUsar el ícono Run de la barra de herramientas de la pestaña del script\n\n\n\nFigure 3: Barra de herramientas del panel Editor\n\n\n\nEl simbolo # indica que lo que sigue es un comentario y por lo tanto R lo ignora cuando es enviado a la consola. Los comentarios pueden ir solos en una línea separada o bien dentro de una línea que tenga algún comando. Si bien no son necesarios para correr el código, los comentarios son muy útiles para estructurar el script y hacer anotaciones para que otros, o nosotros en un futuro, entiendan lo que hace esa parte del script.\nPara guardar el script:\nIr al menu File > Save o usar el atajo de teclado CTRL + S o bien el ícono con el diskette de la barra de herramientas global o de la pestaña del script activo.\nElegir la carpeta destino y el nombre de archivo. Automáticamente se agregará la extensión .R que corresponde a los scripts.\nAyuda!!!\nPor último, y no menos importante, R y RStudio cuentan con un completo sistema de ayuda. Desde la consola se puede acceder usando la función ? seguida del nombre de la función o bien help(\"nombre\")\n\n\n# Pedir ayuda de la función mean\n?mean\nhelp(mean)\n\n\n\nUna de las ventajas de RStudio es que dispone de un panel (Panel #4) dedicado a visualizar las páginas de ayuda. Allí se puede navegar por las páginas utilizando los links, realizar búsquedas, etc. Leer la documentación nunca viene mal y generalmente ahorra dolores de cabeza.\n\n\n\n",
      "last_modified": "2022-03-14T07:26:27-03:00"
    },
    {
      "path": "R_basico.html",
      "title": "¿Cómo es el lenguaje R?",
      "author": [],
      "contents": "\n\nContents\nOperadores matemáticos y lógicos\nVariables y objetos\nTipos de datos\nEstructura de datos\n\nR es un lenguaje de programación orientado al análisis estadístico. Como todo lenguaje tiene sus particularidades. A continuación vamos a ver algunos aspectos básicos de dicho lenguaje que nos permitirá avanzar con las funciones que vamos a usar para analizar datos.\nOperadores matemáticos y lógicos\nLas operaciones matemáticas básicas se realizan usando los símbolos convencionales: suma (+), resta (-), división (/), producto (*) y potencia (^)\nPor ejemplo, \\(1 + \\left( 3 \\times 4 + \\dfrac{5 -2}{3} \\right)^2\\) en R es:\n\n\n1 + (3 * 4 + (5 - 2)/3)^2\n\n\n[1] 170\n\nTambién se pueden evaluar expresiones lógicas: igual (==), distinto (!=), mayor que (>), menor que (<), mayor o igual que (>=), menor o igual que (<=). El resultado es TRUE (verdadero) o FALSE (falso).\nPor ejemplo, podemos evaluar si 3 es igual 4\n\n\n3 == 4\n\n\n[1] FALSE\n\nO si 5 es mayor o igual a 3\n\n\n5 >= 3\n\n\n[1] TRUE\n\nTambién se pueden combinar con los operadores intersección (&), unión (|) y negación (!).\nPor ejemplo, evaluar si se cumplen las dos cosas anteriores a la vez\n\n\n3 == 4 & 5 >= 3\n\n\n[1] FALSE\n\nDevuelve FALSE porque 3 == 4 no es verdadero. Si reemplazamos & por | va a devolver evaluar si una de las dos se cumple:\n\n\n3 == 4 | 5 >= 3\n\n\n[1] TRUE\n\nTambien se pueden combinar con operaciones matemáticas…\n\n\n4 * 2 == 8\n\n\n[1] TRUE\n\nEn este caso primero evalúa 4 * 2 y luego compara el resultado con 8\nVariables y objetos\nUn objeto es un espacio de la memoria que almacena un pedazo de información (una cifra, un conjunto de números, el resultado de un análisis, etc). También se denomina variables ya que su contenido puede cambiar. En R prácticamente todo puede representarse como un objeto.\nLos objetos o variables se crean asignandoles informacicon (números, letras, resultados de operaciones, etc), con el símbolo <- (ALT + -) o =. Esta informacion se puede recuperar, modificar o utilizar para otros cálculos.\nSupongamos que queremos asignar el valor 2 a la variable x.\n\n\nx <- 2\n\n\n\nEn la consola vuelve a aparecer el simbolo > y nada más. En el ambiente se ve una entrada que dice x y el valor. Podemos recuperar el valor en la consola tipeando el nombre del objeto:\n\n\nx\n\n\n[1] 2\n\nTambien podemos reusarlo en otro calculo, por ejemplo obtener 2 veces x.\n\n\n2 * x\n\n\n[1] 4\n\nO bien obtener una nueva variable\n\n\ny <- 2 * x +1\ny\n\n\n[1] 5\n\nAclaración : los nombres de las variables no deben empezar con números ni contener espacios. No pueden usarse operadores (*+-/&%) en los nombres pero puede usarse . o _.\n\n# Mal\n2x <- 3\nmi variable <- 3\n\n# Bien\nx_2 <- 3\nx.2 <- 3\nx2 <- 3\n\nTambién R es sensibles a mayúsculas\n\n\n# Definir 'A' y 'a'\nA <- 3\na <- 5\n\n# Verificar si 'A' y 'a' son lo mismo\nA == a\n\n\n[1] FALSE\n\nVectores\nSon los objetos más simples a partir de los cuales se construyen otros tipos de objetos. Se crean utilizando la función c() (combine) para “combinar” datos del mismo tipo\n\n\nx <- c(13, 45, 67, 45)\nx\n\n\n[1] 13 45 67 45\n\nEn el caso de mezclar de datos, R los va a convertir al tipo de datos más simple.\nPor ejemplo: si queremos crear un vector con 3 valores: lógico, numérico y texto, R va a asumir que todos los elementos son de tipo texto\n\n\ny <- c(TRUE, 34, \"hola\")\ny\n\n\n[1] \"TRUE\" \"34\"   \"hola\"\n\nLos vectores están indexados. Se puede acceder a sus elementos usando el operador [ ] e indicando el número de orden.\nPor ejemplo: para recuperar el 3er elemento del vector x\n\n\ny[3]\n\n\n[1] \"hola\"\n\nVeremos más adelante los distintos tipos.\nFunciones y argumentos\nPara crear los vectores utilizamos una funcion c(). Las funciones dentro de R tienen la siguiente forma\nnombre_funcion(arg1, arg2, ...)\ndonde arg son los argumentos (valores de entrada u opciones). Algunos argumentos toman valores por defecto otros hay que declararlos.\nPor ejemplo, la función round()` tiene los argumentos:\nx, para pasar el número o vector numérico que queremos redondear\ndigits = 0 para indicar el numero de dígitos a usar, por defecto 0.\nSupongamos que queremos redondear el numero 3.141593 a 3 dígitos.\n\n\n# Indicando los argumentos\nround(x = 3.141593, digits = 3)\n\n\n[1] 3.142\n\n# Sin indicar los argumentos\nround(3.141593, 3)\n\n\n[1] 3.142\n\nEn este último caso, el orden de los argumentos es clave ya que R asigna los valores en función de la posición.\n\n\n# Sin indicar los argumentos\nround(3, 3.141593)\n\n\n[1] 3\n\nDevuelve 3 por considera que queremos redondear el número 3\nTipos de datos\nNuméricos (numeric)\nNúmeros racionales (enteros o con coma).\n\n\nx <- c(3, 4, 5)\nclass(x)\n\n\n[1] \"numeric\"\n\nLos números enteros se tratan como numeric a menos que se los convierta con as.integer().\n\n\ny <- as.integer(x)\nclass(y)\n\n\n[1] \"integer\"\n\nLos datos numéricos permiten todas las operaciones algebráicas\n\n\nmean(x)\n\n\n[1] 4\n\nmean(y)\n\n\n[1] 4\n\nTexto (character)\nCadenas de texto o número delimitadas por comillas (simples o dobles, nom mezclar).\n\n\nx <- c(\"hola\", '3')\nclass(x)\n\n\n[1] \"character\"\n\nLógicamente no se pueden realizar operaciones numéricas. R avisa y devuelve NA\n\n\nmean(x)\n\n\n[1] NA\n\nLógicos (logic)\nCondición verdadero (TRUE o T) o falso (FALSE o F)\n\n\nlogico <- c(T, F, T, TRUE, FALSE, F)\nlogico\n\n\n[1]  TRUE FALSE  TRUE  TRUE FALSE FALSE\n\nOtro ejemplo: ¿cuáles de los siguientes números son mayores a 30?\n\n\nx <- c(23, 43, 21, 34, 56, 3, 23, 3)\nx > 30\n\n\n[1] FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE\n\nOtros tipos de datos\nLos valores faltantes se simbolizan en R con NA (not available). Indican que debería haber un valor pero que está faltando.\n\n\nx <- c(1, 2, 3, NA, 4)\nis.na(x)\n\n\n[1] FALSE FALSE FALSE  TRUE FALSE\n\nA diferencia del NA, un valor de tipo NULL indica que no hay información y que tampoco se esperaba que la haya.\n\n\nx <- c(1, 2, 3, NULL, 4)\nx\n\n\n[1] 1 2 3 4\n\nAlgunas operaciones matemáticas devuelven valores NaN (not a number) cuando no están definidas, por ejemplo:\n\n\n0/0\n\n\n[1] NaN\n\nO bien valores infinitos (Inf):\n\n\n1/0\n\n\n[1] Inf\n\nEstructura de datos\nMatriz (matrix)\nColección de vectores de igual longitud y mismo tipo de datos. Se crea con la función matrix(), o combinando filas o columnas de igual longitud con rbind() o cbind().\nPor ejemplo la matriz:\n\\[\n\\mathbf{M} = \\left[\\begin{array}{c c}\n1 & 2 \\\\\n3 & 4 \\\\\n5 & 6 \\\\\n\\end{array} \\right]\n\\] en R se representa así:\n\n\nM <- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2)\nM\n\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\nSe puede indexar usando [n, p] donde n es el numero de fila y p numero de columna. Por ejemplo para obtener el elemento \\(m_{12}\\)\n\n\nM[1,2]\n\n\n[1] 4\n\nO todos los elementos de la columna 2\n\n\nM[, 2]\n\n\n[1] 4 5 6\n\nListas (list)\nEs una generalización de los vectores ya que los elementos pueden ser de igual o diferente tipo de datos\n\n\nlst <- list(23, \"hola\", TRUE)\nlst\n\n\n[[1]]\n[1] 23\n\n[[2]]\n[1] \"hola\"\n\n[[3]]\n[1] TRUE\n\nSe pueden indexar usando [[ ]]\n\n\n# El segundo elemento de l\nlst[[2]]\n\n\n[1] \"hola\"\n\nCada elemento a su vez puede ser cualquier objeto de los vistos anteriormente.\nHoja de datos (data.frame)\nSimilares a las matrices pero cada columna puede ser de un tipo de dato diferente. Útil para guardar datos donde cada fila es un caso y cada columna una variable.\nSupongamos que tenemos la tabla de datos:\nLote\nVariedad\nRendimiento\n1\nEscorpion\n34\n2\nEscorpion\n36\n3\nYarara\n40\n4\nBaguette11\n28\n5\nTijetera\n31\nEn R podemos representarla así:\n\n\ntrigo <- data.frame(\n  lote = 1:5,\n  variedad = c('Escorpion', 'Escorpion', 'Yarara', 'Baguette 11', 'Tijetera'),\n  rendimiento = c(34, 36, 40, 28, 31)\n)\ntrigo\n\n\n  lote    variedad rendimiento\n1    1   Escorpion          34\n2    2   Escorpion          36\n3    3      Yarara          40\n4    4 Baguette 11          28\n5    5    Tijetera          31\n\nAl igual que las matrices, un data.frame se puede indexar con [ ]. Por ejemplo, si quisieramos El bombre de la varidedad de la fila 2\n\n\ntrigo[2, 3]\n\n\n[1] 36\n\nO todos los nombres de la fila 2\n\n\ntrigo[2, ]\n\n\n  lote  variedad rendimiento\n2    2 Escorpion          36\n\nTambien podemos hacer consultas más específicas: “Lotes con rendimiento mayor a 35 qq/ha”\n\n\ntrigo[trigo$rendimiento > 35, ]\n\n\n  lote  variedad rendimiento\n2    2 Escorpion          36\n3    3    Yarara          40\n\nLas variables o columnas se pueden acceder individualmente usando o el operador $ seguido dle nombre de la columna o [, \"nombre\"], o [, posicion]. Ejemplo: extraer la columna rendimiento que es la número 3\n\n\ntrigo$rendimiento\n\n\n[1] 34 36 40 28 31\n\ntrigo[, \"rendimiento\"]\n\n\n[1] 34 36 40 28 31\n\ntrigo[, 3]\n\n\n[1] 34 36 40 28 31\n\nFactores (factor y ordered)\nSi los elementos de vector de tipo texto (character) y representan niveles nominales (categorías), el objeto puede convertirse a factor de modo tal que los valores son reemplazados por un número que se asocia a los niveles del factor (ordenados alfabeticamente, a menos que se indique otra cosa).\nUn ejemplo de un vector tipo character.\n\n\nx <- c('bajo', 'medio', 'alto', 'alto', 'bajo', 'bajo')\nx\n\n\n[1] \"bajo\"  \"medio\" \"alto\"  \"alto\"  \"bajo\"  \"bajo\" \n\nSólo se muestran los valores (bajo, medio y alto). No hay información de niveles. Ahora si aplicamos factor(x):\n\n\ny <- factor(x)\ny\n\n\n[1] bajo  medio alto  alto  bajo  bajo \nLevels: alto bajo medio\n\nLos valores pasaron al atributo levels y los datos fueron reemplazados por los identificadores 2, 3, y 1 según el orden alfabético de los niveles.\n\n\nas.numeric(y)\n\n\n[1] 2 3 1 1 2 2\n\nCuando los niveles tienen una jerarquía u orden, se puede especificar este tipo de relación mediante as.ordered() que convierte el factor en uno especial ordered agregando la relación entre los niveles\n\n\nz <- factor(x, levels = c('bajo', 'medio', 'alto'))\nz <- as.ordered(z)\nz\n\n\n[1] bajo  medio alto  alto  bajo  bajo \nLevels: bajo < medio < alto\n\nLos factores como cualquier vector tambien se indexan con [ ].\n\n\n\n",
      "last_modified": "2022-03-14T07:26:28-03:00"
    }
  ],
  "collections": []
}
