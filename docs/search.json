{
  "articles": [
    {
      "path": "about.html",
      "title": "Acerca de...",
      "author": [],
      "contents": "\r\n\r\nContents\r\nAgustín Alesso\r\nPatricia Acetta\r\n\r\nEste sitio fue preparado por el equipo de Estadística de la FCA.\r\nAgustín Alesso\r\nIngeniero Agrónomo (UNL)\r\nDr. en Ciencias Agropecuarias (UNC)\r\ncalesso@fca.unl.edu.ar\r\nProfesor Adjunto de la UNL. Orienta su investigación en métodos estadísticos y geoestadísticos aplicados a agricultura de precisión, y trabaja en temas relacionados con el análisis de la variabilidad espacial y temporal de rendimientos de cultivos y atributos de suelo y delimitación de zonas de manejo.\r\nPatricia Acetta\r\nIngeniera Agrónoma (UNL)\r\nMg. en Negocios Agroalimentarios (UNL)\r\npacetta@fca.unl.edu.ar\r\nAyudante de cátedra en grado, pregrado y posgrado de la UNL. Orienta su investigación en economía de la producción agropecuaria, análisis de datos de gestión económica y financiera y cambios tecnológicos de empresas agropecuarias, así como su impacto en la toma de decisiones en los agronegocios; formulación y evaluación de proyectos de desarrollo rural. Diplomada en AgroAnalytics (Univ. Austral).\r\n\r\n\r\n\r\n",
      "last_modified": "2023-08-15T23:03:02-03:00"
    },
    {
      "path": "como_crear_proyecto_rstudio.html",
      "title": "¿Cómo crear un proyecto en RStudio?",
      "author": [],
      "contents": "\r\n\r\nContents\r\n¿Qué es un Proyecto?\r\n¿Cómo crar un proyecto?\r\n\r\n¿Qué es un Proyecto?\r\nR trabaja con un directorio de trabajo o working\r\ndirectory que es la dirección o path que figura en el\r\ntitulo del panel Console. Esto se puede averiguar con\r\ngetwd()\r\n\r\n\r\ngetwd()\r\n\r\n\r\n\r\nPor defecto es el directorio base del usuario que depende de cada\r\nplataforma. En linux es el /home/usuario en cambio en\r\nWindows es C:/Users/usuario/Documents.\r\nA menos que se especifique lo contrario, se asume que los archivos de\r\nentrada o salida se ubican en esa. Esto se puede modificar en cualquier\r\nmomento con la función setwd().\r\n\r\n\r\nsetwd(\"ruta/a/otra/carpeta\")\r\n\r\n\r\n\r\nRStudio extiende esta característica a través de los\r\nproyectos o projects. Cada proyecto es una carpeta o\r\nfolder que contienen un archivo .RProj con algunas\r\nconfiguraciones específicas.\r\nAl abrir un proyecto, automáticamente se cambia el directorio de\r\ntrabajo a esta carpeta. Esto permite organizar los archivos de datos,\r\nlas salidas, los scripts, etc., dentro de un directorio de trabajo\r\n(working directory) y volver a ellos de manera más rápida,\r\neficiente, y portable.\r\n¿Cómo crar un proyecto?\r\nPara crear un proyecto en RStudio:\r\nIr a File > New project... o bien el ícono\r\nCreate project de la barra de herramientas.\r\n\r\n\r\n\r\nSeleccionar New Directory y en\r\nProject type seleccionar New project.\r\n\r\n\r\n\r\nUna vez en el cuadro de diálogo Create new project\r\ningresar el nombre del proyecto (e.g. estadistica) en\r\nDirectory name que será a su vez el nombre de la carpeta\r\nque RStudio va a crear por nosotros.\r\nLuego en Create project as a subdirectory of indicar\r\ndonde queremos que RStudio cree la\r\ncarpeta.\r\n\r\n\r\n\r\nSi todo sale bien, se crea la carpeta con el nombre que indicamos y\r\ndentro de ésta un archivo con extensión .Rproj. Este\r\narchivo solamente se usa para abrir el directorio. No se debe\r\nsobreescribir con el script.\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-27T15:00:14-03:00"
    },
    {
      "path": "como_importar_datos_en_R.html",
      "title": "¿Cómo importar datos en R?",
      "author": [],
      "contents": "\r\n\r\nContents\r\nDesde la consola\r\n(recomendado)\r\nDesde el\r\nimportador de datos de RStudio\r\nVerificación de los\r\ndatos\r\n\r\nUn aspecto importante para cualquier análisis de datos es acceder a\r\nlos datos!! Éstos pueden estar almacenados en diversos formatos:\r\narchivos de texto (*.txt, *.dat, etc), texto\r\nseparado por comas (*.csv), planillas de cálculos\r\n(*.xls o *.xlsx), etc.\r\nExisten diversas funciones que vienen por defecto en\r\nR o bien en paquetes específicos que permiten leer\r\nvirtualmente cualquier formato de archivos. El paquete rio\r\nbrinda una interfase unificada y simplificada para realizar esta tarea\r\ndesde la consola. Otra alternativa es el modulo\r\nImport dataset de RStudio.\r\nA continuación veremos como cargar el archivo\r\nurbana_weather.xlsx\r\nque contiene datos meteorológicos de la ciudad de Urbana (IL).\r\nDesde la consola\r\n(recomendado)\r\nUna vez que descargamos el archivo datos en la carpeta\r\ndata dentro de nuestro directorio de trabajo o proyecto\r\npodemos leerlo en R usando la función\r\nimport() del paquete rio. Esta función se\r\nencargará de llamar la función necesaria para leer el archivo que le\r\nsuministremos.\r\n\r\n\r\n# Cargar rio (si no estaba cargado antes)\r\npacman::p_load(rio)\r\n\r\n# importar los datos\r\nurbana <- import(\"./data/urbana_weather.xlsx\", setclass = \"tibble\")\r\nurbana\r\n\r\n\r\n# A tibble: 240 × 4\r\n    YEAR month precip  temp\r\n   <dbl> <chr>  <dbl> <dbl>\r\n 1  2000 Jan     1.54  25.6\r\n 2  2001 Jan     1.32  25.4\r\n 3  2002 Jan     2.81  34  \r\n 4  2003 Jan     0.79  21.1\r\n 5  2004 Jan     2.18  24  \r\n 6  2005 Jan     6.2   27.8\r\n 7  2006 Jan     1.78  37.8\r\n 8  2007 Jan     3.03  29.7\r\n 9  2008 Jan     2.31  26.2\r\n10  2009 Jan     0.68  18.8\r\n# … with 230 more rows\r\n\r\nEl argumento setClass permite especificar en que tipo de\r\nobjeto importarlo. Por defecto es un data.frame. En este\r\ncaso mostramos como indicar que queremos crear un objeto tipo\r\ntibble, que es un data.frame con\r\nanabólicos.\r\nSi sólo estuvieramos ineresados en el rango A1:C5\r\n(primeros 4 registros de las 3 primeras columnas), podríamos usar:\r\n\r\n\r\nurbana2 <- import(file = \"./data/urbana_weather.xlsx\", range = \"A1:C5\")\r\nurbana2\r\n\r\n\r\n  YEAR month precip\r\n1 2000   Jan   1.54\r\n2 2001   Jan   1.32\r\n3 2002   Jan   2.81\r\n4 2003   Jan   0.79\r\n\r\nDesde el importador de\r\ndatos de RStudio\r\nRStudio cuenta con un asistente de importación de\r\ndatos (File > Import Dataset) que brinda interfase a\r\nvarias funciones especializadas en la importación de datos de paquetes\r\nespecíficos como readr, readxl, etc.\r\nEn el menú File > Import Dataset o bien el ícono del\r\npanel Environment despliega una lista con disitintas\r\nopciones de importación: nos interesa\r\nFrom Excel (readxl)...\r\n\r\n\r\n\r\nFigure 1: Importador de datos\r\n\r\n\r\n\r\n\r\n\r\n\r\nFigure 2: Importador de datos\r\n\r\n\r\n\r\nEste menú tiene cuatro paneles:\r\nUna barra de direccion para indicar la ruta al archivo o\r\nURL.\r\nUna vista previa del contenido del archivo\r\nOpciones de importación: aquí se puede especificar el nombre del\r\nobjeto que se creará dentro de R (Name),\r\nla cantidad de lineas a leer, el número de la hoja, el rango de celdas,\r\nlíneas a saltear (skip) y el identificador de datos\r\nNA.\r\nVista previa del código. En esta parte se puede visualizar como\r\nse construye el comando que se ejecturará al clickear en\r\nImport.\r\n\r\nAclaración: es muy importante que el código generado\r\npor este asistente sea incluido en el script para futuras sesiones.\r\n\r\nVerificación de los datos\r\nUna vez importados los datos es conveniente verificar como han sido\r\nleidos en el R.\r\nComo vimos antes, una alternativa es imprimirlo escribiendo\r\nel nombre del objeto directamente en la consola.\r\n\r\n\r\nurbana\r\n\r\n\r\n# A tibble: 240 × 4\r\n    YEAR month precip  temp\r\n   <dbl> <chr>  <dbl> <dbl>\r\n 1  2000 Jan     1.54  25.6\r\n 2  2001 Jan     1.32  25.4\r\n 3  2002 Jan     2.81  34  \r\n 4  2003 Jan     0.79  21.1\r\n 5  2004 Jan     2.18  24  \r\n 6  2005 Jan     6.2   27.8\r\n 7  2006 Jan     1.78  37.8\r\n 8  2007 Jan     3.03  29.7\r\n 9  2008 Jan     2.31  26.2\r\n10  2009 Jan     0.68  18.8\r\n# … with 230 more rows\r\n\r\nOtra alternativa es utilizar la función View() que\r\nmuestra la tabla de datos en un formato de planilla interactiva de solo\r\nlectura.\r\n\r\n\r\nView(urbana)\r\n\r\n\r\n\r\nSi bien podemos inferir que tipo de datos se leyeron, una alternativa\r\nmejor es mirar la estructura con la función str().\r\n\r\n\r\nstr(urbana)\r\n\r\n\r\ntibble [240 × 4] (S3: tbl_df/tbl/data.frame)\r\n $ YEAR  : num [1:240] 2000 2001 2002 2003 2004 ...\r\n $ month : chr [1:240] \"Jan\" \"Jan\" \"Jan\" \"Jan\" ...\r\n $ precip: num [1:240] 1.54 1.32 2.81 0.79 2.18 6.2 1.78 3.03 2.31 0.68 ...\r\n $ temp  : num [1:240] 25.6 25.4 34 21.1 24 27.8 37.8 29.7 26.2 18.8 ...\r\n\r\nEsto nos está diciendo que el objeto es un tibble donde\r\ncada columna es una variable y cada fila una observacion. En nuestro set\r\nde datos hay 4 variables (YEAR, month,\r\nprecip and temp) y 240 observaciones. Junto\r\ncon el nombre de cada variable hay una breve descripción del tipo de\r\ndatos (int para integer, chr para\r\ncharacter y num para numeric) y\r\nuna vista previa de los primeros valores.\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-27T15:00:14-03:00"
    },
    {
      "path": "como_instalar_R_Rstudio.html",
      "title": "¿Cómo instalar R y RStudio?",
      "author": [],
      "contents": "\r\n\r\nContents\r\nInstalación de R\r\nInstalación de RStudio\r\n\r\nR y RStudio se instalan por separado. R puede funcionar sin RStudio, en cambio RStudio necesita que al menos una versión de R esté instalada en el sistema. Ambos softwares son multiplataforma y pueden ser ejecutados en sistemas operativos Windows, Mac OS X y Linux.\r\nEn la página https://posit.co/download/rstudio-desktop/ hay instrucciones específicas para cada plataforma R y RStudio.\r\n\r\n\r\n\r\nFigure 1: Página de descaga de R y RStudio en posit\r\n\r\n\r\n\r\nA continuación se describe el procedimiento para instalar R y RStudio bajo Windows.\r\nInstalación de R\r\n\r\n\r\n\r\nFigure 2: Botón para descaga de R\r\n\r\n\r\n\r\nDescargar el archivo instalador correspondiente a la última versión estable de R desde el CRAN1 (del inglés, Comprenhensive R Archive Network) visitando el siguiente link.\r\n\r\n\r\n\r\nFigure 3: Página de descaga de R\r\n\r\n\r\n\r\n\r\n\r\n\r\nFigure 4: Dirigirse a Install R for firt time\r\n\r\n\r\n\r\n\r\n\r\n\r\nFigure 5: Dirigire a “Download R-X.X.X for Windows”\r\n\r\n\r\n\r\nEjecutar el archivo descargado y seguir el asistente de instalación con todas las opciones por defecto.\r\nSi la instalación ha sido exitosa en el menú Inicio podrá encontrarse la carpeta R que contendrá dos accesos directos a la interfase de usuario mínima que viene con la versión de R para Windows (no abriremos este acceso directo).\r\nInstalación de RStudio\r\n\r\n\r\n\r\nFigure 6: Botón para descaga de RStudio\r\n\r\n\r\n\r\nDescargar el archivo de instalación correspondiente a nuestra plataforma o sistema operativo.\r\nEjecutar el archivo .exe y seguir el asistente de instalación con todas las opciones por defecto.\r\nSi la instalación ha sido exitosa en el menú Inicio dentro de la carpeta RStudio se encontrará el acceso directo a RStudio el cual, mediante el menu contextual (botón derecho del ratón) puede enviarse al Escritorio como acceso directo o bien anclar al menu de Inicio o barra de acceso rápido.\r\n\r\n\r\n\r\nFigure 7: Icono de RStudio\r\n\r\n\r\n\r\n\r\nAhora sí, ya tenemos listo R y RStudio para empezar a trabajar!!\r\n\r\nCRAN es un conjunto de servidores espejo distribuidos alrededor del mundo que tienen copias de R y sus paquetes. No es necesario escojer el espejo más cercano ya que el espejo nube (https://cloud.r-project.org) automáticamente determina de que servidor conviene realizar la descarga.↩︎\r\n",
      "last_modified": "2024-03-08T16:39:30-03:00"
    },
    {
      "path": "como_instalar_y_cargar_paquetes.html",
      "title": "¿Cómo instalar y cargar paquetes en R?",
      "author": [],
      "contents": "\r\n\r\nContents\r\nAlternativa 1:\r\ninstall.packages()/library()\r\nAlternativa 2:\r\npacman\r\nAlternativa 3:\r\nPanel Packages de RStudio\r\n¿library(),\r\npacman o panel Packages?\r\n\r\nR es modular ya que consta de un núcleo básico de\r\nprogramas para realizar operaciones, gráficos y análisis. Estos\r\nprogramas vienen incluidos en el paquete de instalación. No obstante,\r\nexiste un repositorio denominado CRAN (Comprehensive R Archive\r\nNetwork) donde constantemente se van agregando nuevos paquetes para\r\nexpandir las funcionalidades de R.\r\n\r\nIMPORTANTE Para poder acceder a estos paquetes\r\nextra, primero es necesario instalarlos en nuestro sistema y luego,\r\ncuando los necesitemos, cargarlo en la sesión de trabajo.\r\n\r\nPara esto tenemos 3 alternativoas:\r\nFunciones install.packages()/library()\r\nPaquete pacman (recomendada)\r\nPanel Packages de RStudio\r\nA continuación se muestra un ejemplo para instalar los paquetes\r\nnortest y moments\r\nAlternativa 1:\r\ninstall.packages()/library()\r\nSi queremos instalar uno paquetes necesitamos correr por\r\núnica vez la función install.packages()\r\nindicando el nombre del paquete entre comillas:\r\n\r\n\r\n# Un solo paquete\r\ninstall.packages(\"moments\")\r\n\r\n\r\n\r\nSi queremos instalar varios paquetes a la vez podemos crear un vector\r\nque contenga los nombres de los paquetes y usarlo como argumento en la\r\nfunción.\r\n\r\n\r\n# Varios paquetes\r\npaquetes <- c(\"nortest\", \"moments\")\r\ninstall.packages(paquetes)\r\n\r\n\r\n\r\nUna vez instalados, los paquetes se deben cargar en el\r\nentorno o sesión de trabajo usando la función\r\nlibrary().\r\n\r\n\r\n# Cargar el paquerte agricolae\r\nlibrary(moments)\r\n\r\n\r\n\r\nA diferencia de install.packages(), la carga de los\r\npaquetes es individual, es decir, debejos ejecutar\r\nlibrary() por cada paquete que querramos cargar.\r\nAlternativamente si queremos usar alguna función específica sin\r\ncargar el paquete entero podemos usar ::. Por ejemplo, lara\r\nusar la función skewness() del paquete moments\r\npodemos hacer\r\n\r\n\r\nmoments::skewness(x)\r\n\r\n\r\n\r\nSi por alguna circunstancia queremos removerlo del entorno de trabajo\r\n(no del sistemaa), es necesario usar la función\r\ndetach()\r\n\r\n\r\n# Para remover el paquete moments\r\ndetach(\"package:moments\", unload = T)\r\n\r\n\r\n\r\nFinalmente si queremos desinstalarlo de nuestra máquina, es necesario\r\nusar la función remove.packages()\r\n\r\n\r\n# Para remover el paquete moments\r\nremove.packages(\"moments\")\r\n\r\n\r\n\r\nAlternativa 2: pacman\r\nEl proceso anterior se puede simplificar usando el paquete\r\npacman. Pero primero hay que instalarlo por única\r\nvez usando install.packages():\r\n\r\n\r\ninstall.packages(\"pacman\")\r\n\r\n\r\n\r\nLuego, cuando queremos usar un paquete o varios paquetes podemos\r\nllamarlos usando p_load():\r\n\r\n\r\npacman::p_load(moments, nortest)  # no necesitamos usar comillas\r\n\r\n\r\n\r\nEsta función por defecto va a chequear si el o los paquetes indicados\r\nestán instalados antes de cargarlos. Si algun paquete no está instalado,\r\nlo instala y después lo carga. Eso se controla con el argumento\r\ninstall = FALSE.\r\nPara chequear si un paquete esta cargado:\r\n\r\n\r\npacman::p_isloaded(x)\r\n\r\n\r\n\r\nPara remover un paquete de la sesion\r\n\r\n\r\npacman::p_unload(x)\r\n\r\n\r\n\r\nPara remover algun paquete de nuestra biblioteca\r\n\r\n\r\npacman::p_delete(x)\r\n\r\n\r\n\r\nPara buscar un paquete por el nombre, o alguna parte de él\r\n\r\n\r\npacman::p_search_library(\"tidy\")\r\n\r\n\r\n\r\nAlternativa 3: Panel\r\nPackages de RStudio\r\nRStudio cuenta con un panel desde donde podemos\r\ninstalar y cargar paquetes. En ambos casos RStudio\r\ncorre las funciones install.packages() y\r\nlibrary().\r\n\r\n\r\n\r\nFigure 1: Panel Packages\r\n\r\n\r\n\r\nPara instalar por primera vez los paquetes se puede utilizar el ícono\r\nInstall que abre el siguiente cuadro de diálogo.\r\n\r\n\r\n\r\nFigure 2: Cuadro de diálogo para instalar paquetes\r\n\r\n\r\n\r\nPor defecto, RStudio buscará e instalará los\r\npaquetes desde CRAN. En Packages hay que ingresar\r\nlos nombres de los paquetes separados por comas.\r\nRStudio ofrece la posibilidad de ir completando el\r\nnombre si no nos acordamos.\r\nFinalmente, para cargar los paquetes podemos usar el panel\r\nPackages, buscar el paquete que queremos y tildar la\r\ncasilla.\r\n¿library(),\r\npacman o panel Packages?\r\nSi bien el panel Packages brinda una interfase para\r\nseleccionar y cargar los paquetes con un click, esta alternativa tiene\r\nuna desventaja: hay que acordarse en futuras sesiones que es\r\nnecesario cargar ese paquete. Es por eso que incluir un par de\r\nlíneas en el script con la función library() o\r\npacman::p_load()es mejor. pacman tiene la\r\nventaja extra de chequear si el paquete está instalado o no.\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-27T15:00:14-03:00"
    },
    {
      "path": "index.html",
      "title": "Tutoriales de R",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\n\r\nTutoriales de R by ALESSO, CARLOS AGUSTIN & ACETTA PATRICIA  is licensed under CC BY-NC-ND 4.0\r\n\r\nR es un lenguaje y entorno para el procesamiento, visualización y análisis estadístico de datos. Fue creado en 1993 por R. Gentleman y R. Ihaka, ambos científicos del Departamento de Estadística de la Universidad de Auckland (Nueva Zelanda). Actualmente su desarrollo y mantenimiento está a cargo del R Core Team. El sitio oficial del proyecto es www.r-project.org\r\nHoy en día, R es la lingua franca del procesamiento y análisis de datos, tanto en el ámbito académico como comercial dado que es gratiuto, multiplataforma, de código abierto (open source, liberado con licencia GNU/GPL). Esto y el ecosistema de paquetes contribuidos por la comunidad de usuarios lo convierte en un software muy potente ya que expresa el estado del arte de los métodos estadísticos.\r\nLa flexibilidad y potencia de R se basa en su interfaz de comandos (CLI, del inglés command line interface ) que permite la ejecución de comandos de manera interactiva (en consola) o estructurada mediante scripts.\r\nEsta característica impone una curva de aprendizaje lenta. Con el objetivo de acelerar el aprendizaje se ha diseñado este sitio web con orientado a estudiantes de Estadísica 1 y 2 de la carrera de Ingenieria Agronómica de la Facultad de Ciencias Agrarias (Universidad Nacional del Litoral).\r\n\r\n\r\n\r\n",
      "last_modified": "2024-03-08T16:45:52-03:00"
    },
    {
      "path": "introduccion_a_dplyr.html",
      "title": "¿Cómo manipular datos con `dplyr`?",
      "author": [],
      "contents": "\r\n\r\nContents\r\n¿Qué es dplyr?\r\n¿Cómo conseguir\r\ndplyr?\r\nVerbos\r\nimportantes de dplyr para recordar\r\ndplyr en acción\r\n\r\n¿Qué es dplyr?\r\ndplyr es un paquete de R muy potente\r\npara la exploración, transformación y resumen de datos en formato de\r\ntabla con filas (observaciones) y columnas (variables). Es un componente\r\nde un conjunto de packages llamado tidyverse desarrollados\r\npor Hadley Wickham\r\nEl paquete contiene un conjunto de funciones (o verbos) que\r\nrealizan operaciones comunes para el manejo de datos tales como: filtrar\r\nfilas, seleccionar columnas, re-ordenar filas, agregar o transformar\r\ncolumnas, resumir datos. También permite agrupar los datos facilitando\r\nla estrategia split-apply-combine, es decir, dividir\r\n(split) los datos según una variable de grupo, aplicar\r\n(apply) alguna transformación o resumen y combinar\r\n(combine) las partes para presentar los resultados.\r\nSi bien R base tiene funciones que realizan las\r\nmismas tareas (split(), subset(),\r\napply(), sapply(), lapply(),\r\ntapply() and aggregate()), el paquete\r\ndplyr brinda una interface más consistente que permite\r\ntrabajar de manera más facil con data.frame (tabla de\r\ndatos) más que con vectores.\r\n¿Cómo conseguir dplyr?\r\nPara instalar por primera vez en la computadora:\r\n\r\n\r\n# Solo\r\ninstall.packages(\"dplyr\")\r\n\r\n# O junto con la familia tidyverse\r\ninstall.packages(\"tidyverse\")\r\n\r\n\r\n\r\nLo anterior se debe realizar por única vez si el paquete no está\r\npreviamente instalado en la máquina. Para usar las funciones en una\r\nsesion de trabajo hay que cargarlo con library():\r\n\r\n\r\n# Solo\r\nlibrary(\"dplyr\")\r\n\r\n# O junto con la familia tidyverse\r\nlibrary(\"tidyverse\")\r\n\r\n\r\n\r\nR va a avisarnos en la consola que esta enmascarando\r\n(reemplazando) algunas funciones que ya estaban en el entorno, o bien el\r\npaquete nos devuelve algun mensaje. A menos que diga\r\nError ..., eso está bien.\r\nVerbos importantes de\r\ndplyr para recordar\r\nToda la estrategia de trabajo con datos de dplyr se basa\r\nen 6 verbos:\r\nverbo\r\ndescripción\r\nselect()\r\nselecciona columnas (variables)\r\nfilter()\r\nfiltra o selecciona las filas\r\n(observaciones)\r\narrange()\r\nre-ordena las filas\r\nmutate()\r\ncrea nuevas columnas o modifica las\r\npreexistentes\r\nsummarise()\r\nresumen los valores de una variable\r\ngroup_by()\r\npermite aplicar los verbos anteriores en\r\nsubgrupos (split-apply-combine)\r\nsample_n()\r\npara tomar muestras aleatorias con o sin\r\nreposición\r\nEn la mayoría de los casos la sintaxis es:\r\nfunction(que_datos, que_hacer_con_los_datos)\r\nEn que_datos hay que poner el nombre del set de datos o\r\ndata.frame (a menos que se use el operador\r\n%>% para encadenar, mas adelante) y en\r\nque_hacer_con_los_datos indicar que operación, condicion,\r\ntransformacion, etc aplicar a las filas y columnas.\r\ndplyr en acción\r\nPara ilustrar el uso del paquete vamos a usar los datos contenidos en\r\nel archivo pesada_terneros.xlsx.\r\nPara más detalles ir a la hoja de descripción de datos.\r\n\r\n\r\n# Cargar los datos con readxl\r\nlibrary(readxl)\r\nterneros <- read_excel(\"./data/pesada_terneros.xlsx\")\r\n\r\n\r\n\r\nSeleccionando variables\r\nUna tareas básicas cuando se exploran datos es la selección de\r\ncolumnas de interés (variables). Esto se lleva a cabo con\r\nselect().\r\nPara seleccionar las columnas Procedencia,\r\nIDV y Peso:\r\n\r\n\r\n# Sin asignar\r\nselect(terneros, Procedencia, IDV, Peso)\r\n\r\n\r\n# A tibble: 1,598 × 3\r\n   Procedencia IDV        Peso\r\n   <chr>       <chr>     <dbl>\r\n 1 La Rosita   NR047A202   204\r\n 2 La Rosita   GN685B267   186\r\n 3 La Rosita   AI101A751   182\r\n 4 La Rosita   TM603C877   186\r\n 5 La Rosita   TM420B797   186\r\n 6 La Rosita   LH837F500   208\r\n 7 La Rosita   NR047A217   170\r\n 8 La Rosita   LH837F508   188\r\n 9 La Rosita   GN685B256   172\r\n10 La Rosita   QW110A058   172\r\n# … with 1,588 more rows\r\n\r\n# Creando un nuevo set de datos\r\nmis_columnas <- select(terneros, Procedencia, IDV, Peso)\r\n\r\n\r\n\r\nPor defecto, si no se asigna a un nuevo objeto, el resultado de la\r\noperación se imprime en la consola con la función print()\r\nla cual por defecto muestra las 10 primeras observaciones y la cantidad\r\nde columnas que entran en la pantalla. Aquellas columnas que no entran\r\nson indicadas al pie.\r\nSi quiero ver más registros se puede usar el argumento\r\nn = de print()\r\n\r\n\r\nprint(mis_columnas, n = 15)\r\n\r\n\r\n# A tibble: 1,598 × 3\r\n   Procedencia IDV        Peso\r\n   <chr>       <chr>     <dbl>\r\n 1 La Rosita   NR047A202   204\r\n 2 La Rosita   GN685B267   186\r\n 3 La Rosita   AI101A751   182\r\n 4 La Rosita   TM603C877   186\r\n 5 La Rosita   TM420B797   186\r\n 6 La Rosita   LH837F500   208\r\n 7 La Rosita   NR047A217   170\r\n 8 La Rosita   LH837F508   188\r\n 9 La Rosita   GN685B256   172\r\n10 La Rosita   QW110A058   172\r\n11 La Rosita   LH837F497   188\r\n12 La Rosita   TM420B803   180\r\n13 La Rosita   LH837F514   198\r\n14 La Rosita   II641B940   200\r\n15 La Rosita   IY735C      242\r\n# … with 1,583 more rows\r\n\r\nCon n = \"all\" se imprimen todas (no se muestra por\r\nrazones obvias)\r\nEl orden en que aparecen las variables en el resultado es el orden\r\nque se utilizó al seleccionarlas.\r\n\r\n\r\n# El orden altera el producto\r\nselect(terneros, Procedencia, IDV, Peso)\r\n\r\n\r\n# A tibble: 1,598 × 3\r\n   Procedencia IDV        Peso\r\n   <chr>       <chr>     <dbl>\r\n 1 La Rosita   NR047A202   204\r\n 2 La Rosita   GN685B267   186\r\n 3 La Rosita   AI101A751   182\r\n 4 La Rosita   TM603C877   186\r\n 5 La Rosita   TM420B797   186\r\n 6 La Rosita   LH837F500   208\r\n 7 La Rosita   NR047A217   170\r\n 8 La Rosita   LH837F508   188\r\n 9 La Rosita   GN685B256   172\r\n10 La Rosita   QW110A058   172\r\n# … with 1,588 more rows\r\n\r\nTambién se puede usar los comnados starts_with(),\r\nends_with(), contains(), etc (ver\r\n?select_helpers) para más opciones). Para elegir varias\r\ncolumnas que tienen un patron sin tener que tipear todos los\r\nnombres.\r\n\r\n\r\n# Selecciona columnas que empiezan con P\r\nselect(terneros, starts_with(\"P\"))\r\n\r\n\r\n# A tibble: 1,598 × 2\r\n   Procedencia  Peso\r\n   <chr>       <dbl>\r\n 1 La Rosita     204\r\n 2 La Rosita     186\r\n 3 La Rosita     182\r\n 4 La Rosita     186\r\n 5 La Rosita     186\r\n 6 La Rosita     208\r\n 7 La Rosita     170\r\n 8 La Rosita     188\r\n 9 La Rosita     172\r\n10 La Rosita     172\r\n# … with 1,588 more rows\r\n\r\nPara omitir algunas columnas en la seleccion se puede usar el\r\n- antes del nombre.\r\n\r\n\r\n# Selecciona columnas que empiezan con P\r\nselect(terneros, -IDV, -starts_with(\"P\"))\r\n\r\n\r\n# A tibble: 1,598 × 5\r\n   Sexo  `Fecha Ingreso`     Categoria Fecha              \r\n   <chr> <dttm>              <chr>     <dttm>             \r\n 1 Macho 2017-07-20 00:00:00 Ternero   2017-04-06 00:00:00\r\n 2 Macho 2017-07-20 00:00:00 Ternero   2017-04-06 00:00:00\r\n 3 Macho 2017-07-21 00:00:00 Ternero   2017-04-06 00:00:00\r\n 4 Macho 2017-07-20 00:00:00 Ternero   2017-04-06 00:00:00\r\n 5 Macho 2017-07-24 00:00:00 Ternero   2017-04-06 00:00:00\r\n 6 Macho 2017-07-24 00:00:00 Ternero   2017-04-06 00:00:00\r\n 7 Macho 2017-07-21 00:00:00 Ternero   2017-04-06 00:00:00\r\n 8 Macho 2017-07-24 00:00:00 Ternero   2017-04-06 00:00:00\r\n 9 Macho 2017-07-21 00:00:00 Ternero   2017-04-06 00:00:00\r\n10 Macho 2017-07-24 00:00:00 Ternero   2017-04-06 00:00:00\r\n# … with 1,588 more rows, and 1 more variable: Hora <dttm>\r\n\r\nSeleccionando observaciones\r\nOtra tarea muy frecuente es seleccionar casos o observaciones que\r\ncumplan con alguna condición. Esto se lleva a cabo con\r\nfilter(). Se pueden usar los operadores booleanos\r\n==, >, <,\r\n>=, <=, !=,\r\n%in%) para crear pruebas o condiciones lógicas.\r\nPara seleccionar los terneros de Los Corralitos:\r\n\r\n\r\n# Sin asignar\r\nfilter(terneros, Procedencia == 'Los Corralitos')\r\n\r\n\r\n# A tibble: 575 × 8\r\n   IDV       Procedencia    Sexo  `Fecha Ingreso`     Categoria\r\n   <chr>     <chr>          <chr> <dttm>              <chr>    \r\n 1 PO150A167 Los Corralitos Macho 2017-07-23 00:00:00 Ternero  \r\n 2 PO150A168 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 3 PO150A169 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 4 PO150A460 Los Corralitos Macho 2017-07-23 00:00:00 Ternero  \r\n 5 PO150A673 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 6 PO150A461 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 7 PO150A462 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 8 PO150A463 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 9 PO150A433 Los Corralitos Macho 2017-06-06 00:00:00 Ternero  \r\n10 PO150A434 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n# … with 565 more rows, and 3 more variables: Fecha <dttm>,\r\n#   Hora <dttm>, Peso <dbl>\r\n\r\n# Creando un nuevo set de datos\r\ncorralitos <- filter(terneros, Procedencia == 'Los Corralitos')\r\n\r\n\r\n\r\nLa seleccion se puede hacer por más de una condicion. Por ejemplo,\r\nseleccionar los de Los Corralitos que pesen más de 200\r\nkg:\r\n\r\n\r\nfilter(terneros, Procedencia == 'Los Corralitos', Peso > 200)\r\n\r\n\r\n# A tibble: 260 × 8\r\n   IDV       Procedencia    Sexo  `Fecha Ingreso`     Categoria\r\n   <chr>     <chr>          <chr> <dttm>              <chr>    \r\n 1 PO150A167 Los Corralitos Macho 2017-07-23 00:00:00 Ternero  \r\n 2 PO150A168 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 3 PO150A169 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 4 PO150A673 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 5 PO150A462 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 6 PO150A463 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 7 PO150A434 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 8 PO150A435 Los Corralitos Macho 2017-07-23 00:00:00 Ternero  \r\n 9 PO150A675 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n10 PO150A681 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n# … with 250 more rows, and 3 more variables: Fecha <dttm>,\r\n#   Hora <dttm>, Peso <dbl>\r\n\r\nfilter() asume que cada condicion se debe cumplir en\r\nsimultaneo para que la observación sea seleccionada. Esto equivale a\r\nutilizar el operador & (Y). En caso de querer\r\nseleccionar aquellos registros que cumple una u otra condicion se usa el\r\noperador | (O). Poniendo ! delante de\r\nla condicion se invierte la selección.\r\n\r\n\r\n# Operador &\r\nfilter(terneros, Procedencia == 'Los Corralitos' & Peso > 200)\r\n\r\n\r\n# A tibble: 260 × 8\r\n   IDV       Procedencia    Sexo  `Fecha Ingreso`     Categoria\r\n   <chr>     <chr>          <chr> <dttm>              <chr>    \r\n 1 PO150A167 Los Corralitos Macho 2017-07-23 00:00:00 Ternero  \r\n 2 PO150A168 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 3 PO150A169 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 4 PO150A673 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 5 PO150A462 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 6 PO150A463 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 7 PO150A434 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 8 PO150A435 Los Corralitos Macho 2017-07-23 00:00:00 Ternero  \r\n 9 PO150A675 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n10 PO150A681 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n# … with 250 more rows, and 3 more variables: Fecha <dttm>,\r\n#   Hora <dttm>, Peso <dbl>\r\n\r\n# Operador |\r\nfilter(terneros, Procedencia == 'Los Corralitos' | Peso > 200)\r\n\r\n\r\n# A tibble: 779 × 8\r\n   IDV       Procedencia  Sexo  `Fecha Ingreso`     Categoria\r\n   <chr>     <chr>        <chr> <dttm>              <chr>    \r\n 1 NR047A202 La Rosita    Macho 2017-07-20 00:00:00 Ternero  \r\n 2 LH837F500 La Rosita    Macho 2017-07-24 00:00:00 Ternero  \r\n 3 IY735C    La Rosita    Macho 2017-07-22 00:00:00 Ternero  \r\n 4 QW110A072 La Rosita    Macho 2017-07-24 00:00:00 Ternero  \r\n 5 LH837F526 La Rosita    Macho 2017-07-20 00:00:00 Ternero  \r\n 6 DS289A491 La Rosita    Macho 2017-07-24 00:00:00 Ternero  \r\n 7 TL698HK39 La Rosita    Macho 2017-07-20 00:00:00 Ternero  \r\n 8 LH837F538 La Rosita    Macho 2017-07-21 00:00:00 Ternero  \r\n 9 IW751A017 La Rosita    Macho 2017-07-24 00:00:00 Ternero  \r\n10 NO133A004 Las Glicinas Macho 2017-07-23 00:00:00 Ternero  \r\n# … with 769 more rows, and 3 more variables: Fecha <dttm>,\r\n#   Hora <dttm>, Peso <dbl>\r\n\r\nCon el operador %in% se puede especificar un rango de\r\nvalores que deben cumplir. Por ejemplo terneros de\r\nLos Corralitos, Las Glicinas y\r\nDon Alberto\r\n\r\n\r\n# Indicando cada nombre\r\nfilter(terneros, Procedencia == 'Los Corralitos', Procedencia == 'Las Glicinas', Procedencia == 'Don Alberto')\r\n\r\n\r\n# A tibble: 0 × 8\r\n# … with 8 variables: IDV <chr>, Procedencia <chr>, Sexo <chr>,\r\n#   Fecha Ingreso <dttm>, Categoria <chr>, Fecha <dttm>, Hora <dttm>,\r\n#   Peso <dbl>\r\n\r\n# Más resumido con %in%\r\nfilter(terneros, Procedencia %in% c('Los Corralitos', 'Las Glicinas', 'Don Alberto'))\r\n\r\n\r\n# A tibble: 1,138 × 8\r\n   IDV       Procedencia  Sexo  `Fecha Ingreso`     Categoria\r\n   <chr>     <chr>        <chr> <dttm>              <chr>    \r\n 1 SZ208I507 Las Glicinas Macho 2017-07-20 00:00:00 Ternero  \r\n 2 SZ208H993 Las Glicinas Macho 2017-06-05 00:00:00 Ternero  \r\n 3 SZ208H849 Las Glicinas Macho 2017-06-05 00:00:00 Ternero  \r\n 4 SZ208H777 Las Glicinas Macho 2017-06-05 00:00:00 Ternero  \r\n 5 GT542A562 Las Glicinas Macho 2017-07-21 00:00:00 Ternero  \r\n 6 OQ152A550 Las Glicinas Macho 2017-07-21 00:00:00 Ternero  \r\n 7 NO133A057 Las Glicinas Macho 2017-07-24 00:00:00 Ternero  \r\n 8 SZ208H888 Las Glicinas Macho 2017-07-22 00:00:00 Ternero  \r\n 9 OQ152A566 Las Glicinas Macho 2017-07-20 00:00:00 Ternero  \r\n10 NO133A047 Las Glicinas Macho 2017-07-20 00:00:00 Ternero  \r\n# … with 1,128 more rows, and 3 more variables: Fecha <dttm>,\r\n#   Hora <dttm>, Peso <dbl>\r\n\r\nEncadenando operaciones\r\n(operador %>%)\r\ndplyr importa el operador %>% de otro\r\npaquete llamado magrittr. Este operador permite encadenar\r\noperaciones realizadas con los verbos. De este modo no hay que ir\r\ncreando tablas intermedias o anidar funciones. El operador traduce como\r\nluego y se le de izquierda a derecha y se puede.\r\nEjemplo: Reportar los IDV y peso de los terneros con más de 250 kg.\r\nEsto implicaría seleccionar las columnas de interés y luego filtrar la\r\ntabla o vice versa.\r\n\r\n\r\n# Creando tablas intermedias\r\nterneros2 <- select(terneros, IDV, Peso)\r\nterneros2\r\n\r\n\r\n# A tibble: 1,598 × 2\r\n   IDV        Peso\r\n   <chr>     <dbl>\r\n 1 NR047A202   204\r\n 2 GN685B267   186\r\n 3 AI101A751   182\r\n 4 TM603C877   186\r\n 5 TM420B797   186\r\n 6 LH837F500   208\r\n 7 NR047A217   170\r\n 8 LH837F508   188\r\n 9 GN685B256   172\r\n10 QW110A058   172\r\n# … with 1,588 more rows\r\n\r\nterneros2 <- filter(terneros2, Peso > 250)\r\nterneros2\r\n\r\n\r\n# A tibble: 75 × 2\r\n   IDV        Peso\r\n   <chr>     <dbl>\r\n 1 NO133A004   258\r\n 2 OQ152A456   258\r\n 3 NO133A006   256\r\n 4 OQ152A553   256\r\n 5 PO150A166   290\r\n 6 PO150A674   256\r\n 7 PO150A656   272\r\n 8 NO133A045   264\r\n 9 PO150A571   264\r\n10 PO150A686   262\r\n# … with 65 more rows\r\n\r\n# Anidando\r\nfilter(select(terneros, IDV, Peso), Peso > 250)\r\n\r\n\r\n# A tibble: 75 × 2\r\n   IDV        Peso\r\n   <chr>     <dbl>\r\n 1 NO133A004   258\r\n 2 OQ152A456   258\r\n 3 NO133A006   256\r\n 4 OQ152A553   256\r\n 5 PO150A166   290\r\n 6 PO150A674   256\r\n 7 PO150A656   272\r\n 8 NO133A045   264\r\n 9 PO150A571   264\r\n10 PO150A686   262\r\n# … with 65 more rows\r\n\r\n# Usando %>%\r\nterneros %>%\r\n  select(IDV, Peso) %>%\r\n  filter(Peso >  250)\r\n\r\n\r\n# A tibble: 75 × 2\r\n   IDV        Peso\r\n   <chr>     <dbl>\r\n 1 NO133A004   258\r\n 2 OQ152A456   258\r\n 3 NO133A006   256\r\n 4 OQ152A553   256\r\n 5 PO150A166   290\r\n 6 PO150A674   256\r\n 7 PO150A656   272\r\n 8 NO133A045   264\r\n 9 PO150A571   264\r\n10 PO150A686   262\r\n# … with 65 more rows\r\n\r\nCon %>% se puede omitir el nombre de la tabla sobre\r\nla que se está trabajando (bonus: menos tipeo).\r\nLa última opción se lee: _tomar la tabla terneros,\r\nluego seleccionar las columnas IDV y\r\nPeso, luego filtrar los terneros con pesos\r\nmayores a 250 kg.\r\nEl operador de encadenamiento es muy útil cuando se encadenan muchas\r\noperaciones.\r\nOrdenar las filas\r\nPara ordenar según algun criterio aplicado a las columnas se usa\r\narrange(). Por ejemplo, continuar con lo anterior pero\r\nmostrar ordenadospor peso.\r\n\r\n\r\n# Ordenar de menor a mayor\r\nterneros %>%\r\n  select(IDV, Peso) %>%\r\n  filter(Peso >  250) %>%\r\n  arrange(Peso)\r\n\r\n\r\n# A tibble: 75 × 2\r\n   IDV        Peso\r\n   <chr>     <dbl>\r\n 1 PO150A546   252\r\n 2 NS509H081   252\r\n 3 PO15A710    252\r\n 4 NO133A019   254\r\n 5 PO150A784   254\r\n 6 IA671B182   254\r\n 7 IA671B176   254\r\n 8 PO150A716   254\r\n 9 NO133A006   256\r\n10 OQ152A553   256\r\n# … with 65 more rows\r\n\r\nCon decs(variable) se ordena de mayor a menor\r\n\r\n\r\n# Ordenar de mayor a menor\r\nterneros %>%\r\n  select(IDV, Peso) %>%\r\n  filter(Peso >  250) %>%\r\n  arrange(desc(Peso))\r\n\r\n\r\n# A tibble: 75 × 2\r\n   IDV        Peso\r\n   <chr>     <dbl>\r\n 1 PO150A679   304\r\n 2 IA671B041   294\r\n 3 MM429A932   292\r\n 4 PO150A166   290\r\n 5 PO150A763   288\r\n 6 IA671B106   288\r\n 7 NS509G964   286\r\n 8 PO150A821   284\r\n 9 IA671B045   282\r\n10 NO133A000   280\r\n# … with 65 more rows\r\n\r\nCrear o transformar columnas\r\nPara crear nuevas columnas aplicando funciones a otras, o bien para\r\ntransformar columnas se usa mutate(). Se pueden modificar\r\nmás de una columna a la vez. Por ejemplo, suponiendo que interesa\r\nobtener el logaritmo natura de los pesos o elevar los pesos al\r\ncuadrado.\r\n\r\n\r\nterneros %>% \r\n  mutate(log_peso = log(Peso), peso2 = Peso**2) %>%\r\n  select(Peso, log_peso, peso2)                        # para que se vea mejor el resultado \r\n\r\n\r\n# A tibble: 1,598 × 3\r\n    Peso log_peso peso2\r\n   <dbl>    <dbl> <dbl>\r\n 1   204     5.32 41616\r\n 2   186     5.23 34596\r\n 3   182     5.20 33124\r\n 4   186     5.23 34596\r\n 5   186     5.23 34596\r\n 6   208     5.34 43264\r\n 7   170     5.14 28900\r\n 8   188     5.24 35344\r\n 9   172     5.15 29584\r\n10   172     5.15 29584\r\n# … with 1,588 more rows\r\n\r\nEsto no cambia el set de datos terneros ya que no se lo\r\nasignó a ningun objeto. Para sobreescribir o actualiza el set de datos\r\nterneros hay que asignarlo al mismo objeto.\r\n\r\n\r\nterneros <- terneros %>% \r\n  mutate(log_peso = log(Peso), peso2 = Peso**2)\r\n\r\n\r\n\r\nAclaración: Si se hubiese usado select() el set de datos\r\nterneros solamente contendría las columnas seleccionadas.\r\nOtro ejemplo más útil: calcular los z-scores de los peso (para ello\r\nse requiere calcular el promedio y desvio) y crear una columna que\r\nindique si es un outlier y luego reportar los que son outliers.\r\n\r\n\r\nterneros %>% \r\n  mutate(z = (Peso - mean(Peso))/sd(Peso), outlier = ifelse(abs(z) > 3, \"si\", \"no\")) %>%\r\n  filter(outlier == \"si\") %>%\r\n  select(IDV)\r\n\r\n\r\n# A tibble: 2 × 1\r\n  IDV      \r\n  <chr>    \r\n1 PO150A679\r\n2 IA671B041\r\n\r\nResmuir datos\r\nMediante summarise() se pueden aplicar funciones para\r\nresumir en un solo valor los valores de las columnas. Las funciones a\r\naplicar deben devolver un único valor, por ejemplo mean().\r\nSi usamos summary() esto devolverá 6 valores y dará\r\nerror.\r\n\r\n\r\nterneros %>%\r\n  summarise(media = mean(Peso), sd = sd(Peso), n = n(), suma = sum(Peso), procedencias = n_distinct(Procedencia))\r\n\r\n\r\n# A tibble: 1 × 5\r\n  media    sd     n   suma procedencias\r\n  <dbl> <dbl> <int>  <dbl>        <int>\r\n1  183.  37.0  1598 291802            7\r\n\r\nNuevamente estos resultados pueden asignarse a otro objeto o bien\r\nencadenarse con otras operaciones.\r\nOtro ejemplo, obtener la cantidad de terneros de cada procedencia\r\n\r\n\r\nterneros %>%\r\n  count(Procedencia)\r\n\r\n\r\n# A tibble: 7 × 2\r\n  Procedencia        n\r\n  <chr>          <int>\r\n1 Don Alberto       69\r\n2 La Alameda       201\r\n3 La Estrella      118\r\n4 La Rosita         98\r\n5 La Segunda        43\r\n6 Las Glicinas     494\r\n7 Los Corralitos   575\r\n\r\nOtro ejemplo más, cantidad de terneros de cada procedencia separados\r\nen mayor o menor a 200 kg\r\n\r\n\r\nterneros %>%\r\n  count(Procedencia, Peso > 200)\r\n\r\n\r\n# A tibble: 14 × 3\r\n   Procedencia    `Peso > 200`     n\r\n   <chr>          <lgl>        <int>\r\n 1 Don Alberto    FALSE           49\r\n 2 Don Alberto    TRUE            20\r\n 3 La Alameda     FALSE          136\r\n 4 La Alameda     TRUE            65\r\n 5 La Estrella    FALSE          112\r\n 6 La Estrella    TRUE             6\r\n 7 La Rosita      FALSE           89\r\n 8 La Rosita      TRUE             9\r\n 9 La Segunda     FALSE            5\r\n10 La Segunda     TRUE            38\r\n11 Las Glicinas   FALSE          428\r\n12 Las Glicinas   TRUE            66\r\n13 Los Corralitos FALSE          315\r\n14 Los Corralitos TRUE           260\r\n\r\nAgrupar (último pero no\r\nmenos importante)\r\nEl verbo group_by() es muy útil para aplicar operaciones\r\nen subgrupos y presentar todo junto (split-apply-combine). Lo\r\nque hace es indicar que en el data.frame hay una o más\r\nvariables que conforman los grupos. Luego cada operación se aplica a\r\nesos subgrupos.\r\nEjemplo: calcular media, desvio, n y suma para cada procedencia.\r\n\r\n\r\nterneros %>%\r\n  group_by(Procedencia) %>%\r\n  summarise(media = mean(Peso), sd = sd(Peso), n = n(), suma = sum(Peso))\r\n\r\n\r\n# A tibble: 7 × 5\r\n  Procedencia    media    sd     n   suma\r\n  <chr>          <dbl> <dbl> <int>  <dbl>\r\n1 Don Alberto     179.  26.9    69  12354\r\n2 La Alameda      190.  39.5   201  38192\r\n3 La Estrella     179.  14.2   118  21138\r\n4 La Rosita       180.  17.4    98  17620\r\n5 La Segunda      229.  24.8    43   9868\r\n6 Las Glicinas    160.  33.7   494  79254\r\n7 Los Corralitos  197.  35.2   575 113376\r\n\r\nMuestrear\r\nEl verbo sample_n() and sample_frac() son\r\nútiles para tomar muestras aleatorias (con o sin reposición) de un\r\nconjunto de observaciones. También se puede hacer por subgrupo!\r\n\r\n\r\n# Una muestra de 50 novillos\r\nmuestra50 <- terneros %>%\r\n  sample_n(50)\r\nmuestra50\r\n\r\n\r\n# A tibble: 50 × 10\r\n   IDV       Procedencia    Sexo  `Fecha Ingreso`     Categoria\r\n   <chr>     <chr>          <chr> <dttm>              <chr>    \r\n 1 JM173A252 La Alameda     Macho 2017-07-24 00:00:00 Ternero  \r\n 2 CW828Z158 La Rosita      Macho 2017-07-20 00:00:00 Ternero  \r\n 3 JM173A274 La Alameda     Macho 2017-07-21 00:00:00 Ternero  \r\n 4 OH874D871 La Alameda     Macho 2017-07-21 00:00:00 Ternero  \r\n 5 NS509G975 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n 6 SZ208I511 Las Glicinas   Macho 2017-07-21 00:00:00 Ternero  \r\n 7 IA671B212 La Alameda     Macho 2017-07-24 00:00:00 Ternero  \r\n 8 PO150A642 Los Corralitos Macho 2017-07-20 00:00:00 Ternero  \r\n 9 SZ208H840 Las Glicinas   Macho 2017-07-24 00:00:00 Ternero  \r\n10 NS509H025 Los Corralitos Macho 2017-07-22 00:00:00 Ternero  \r\n# … with 40 more rows, and 5 more variables: Fecha <dttm>,\r\n#   Hora <dttm>, Peso <dbl>, log_peso <dbl>, peso2 <dbl>\r\n\r\n# Una muestra de 10 novillos de cada procedencia\r\nmuestra_procedencia <- terneros %>%\r\n  group_by(Procedencia) %>%\r\n  sample_n(10)\r\nmuestra_procedencia\r\n\r\n\r\n# A tibble: 70 × 10\r\n# Groups:   Procedencia [7]\r\n   IDV       Procedencia Sexo  `Fecha Ingreso`     Categoria\r\n   <chr>     <chr>       <chr> <dttm>              <chr>    \r\n 1 GH738B338 Don Alberto Macho 2017-06-16 00:00:00 Ternero  \r\n 2 GH738B354 Don Alberto Macho 2017-07-21 00:00:00 Ternero  \r\n 3 GH738B326 Don Alberto Macho 2017-07-20 00:00:00 Ternero  \r\n 4 GH738B381 Don Alberto Macho 2017-07-22 00:00:00 Ternero  \r\n 5 GH738B368 Don Alberto Macho 2017-06-16 00:00:00 Ternero  \r\n 6 GH738B380 Don Alberto Macho 2017-07-21 00:00:00 Ternero  \r\n 7 GH738B350 Don Alberto Macho 2017-07-22 00:00:00 Ternero  \r\n 8 GH738B330 Don Alberto Macho 2017-06-16 00:00:00 Ternero  \r\n 9 GH738B386 Don Alberto Macho 2017-07-21 00:00:00 Ternero  \r\n10 GH738B357 Don Alberto Macho 2017-06-16 00:00:00 Ternero  \r\n# … with 60 more rows, and 5 more variables: Fecha <dttm>,\r\n#   Hora <dttm>, Peso <dbl>, log_peso <dbl>, peso2 <dbl>\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-27T15:00:14-03:00"
    },
    {
      "path": "introduccion_a_ggplot2.html",
      "title": "¿Cómo visualizar datos con `ggplot2`?",
      "author": [],
      "contents": "\r\n\r\nContents\r\n¿Cómo conseguir\r\nggplot2?\r\nComponentes del\r\ngráfico en ggplot2\r\nPrimer gráfico paso a\r\npaso\r\nGráficos\r\ncondicionales o por paneles: facets\r\nTemas\r\n\r\nR tiene por defecto el paquete\r\ngraphics, también conocido como base plot system,\r\nque provee la función genérica plot() para hacer gráficos\r\nsimples, y otras funciones para gráficos específicos\r\n(hist(), barplot(), boxplot(),\r\netc).\r\nUsa un enfoque de papel y lapiz por capas donde el gráfico\r\nfinal es una sumatoria de capas que se agregan una a la vez sin\r\nposibilidad de modificarse luego. Generalmente es OK para gráficos\r\nsimples o exploratorios. Para gráficos más complejos (con subgrupos o\r\nmultipanel) requiere programar más. Una desventaja es la sintaxis poco\r\nconsistente.\r\nEl paquete ggplot2, desarrollado por Hadley Wickham, está basado en la filosofía\r\nGramática de gráficos ( grammar of graphics , por eso\r\ngg). Combina los dos enfoques: por capas y\r\nfunción.\r\nUno provee los datos, indica que variables asignar a las estéticas\r\n(ejes, escalas, colores, símbolos) y las geometrías o formas que se\r\nquieren graficar y ggplot2 se encarga del resto. Se puede\r\nir agregando capas. Es muy potente para la exploración y visualización\r\nde datos en formato de tabla con filas (observaciones) y columnas\r\n(variables).\r\n¿Cómo conseguir\r\nggplot2?\r\nPara instalarlo por primera vez en la computadora tenemos las\r\nsiguientes alternativas:\r\n\r\n\r\n# Sólamente el paquete ggplot2\r\ninstall.packages(\"ggplot2\")\r\n\r\n# O junto con la familia tidyverse\r\ninstall.packages(\"tidyverse\")\r\n\r\n\r\n\r\nLo anterior se debe realizar por única vez si el paquete no está\r\npreviamente instalado en la máquina. Para usar las funciones en una\r\nsesion de trabajo hay que cargarlo con library():\r\n\r\n\r\n# Solo\r\nlibrary(\"ggplot2\")\r\n\r\n# O junto con la familia tidyverse\r\nlibrary(\"tidyverse\")\r\n\r\n\r\n\r\n\r\n\r\nlibrary(\"ggplot2\")\r\n\r\n\r\n\r\nR va a avisarnos en la consola que esta enmascarando\r\n(reemplazando) algunas funciones que ya estaban en el entorno, o bien el\r\npaquete nos devuelve algun mensaje. A menos que diga\r\nError ..., eso está bien.\r\nComponentes del gráfico en\r\nggplot2\r\nggplot2 implementa una variante por capas de\r\neste paradigma gramática de gráficos de Leland\r\nWilkinson (gg es por grammar of graphics).\r\nComo resultado, se crean una serie de capas que permiten describir y\r\nconstruir visualizaciones de manera estructurada en cuanto a\r\nrepresentación de los elementos pero a su vez flexible para generar\r\ncombinaciones nuevas.\r\nUn gráfico se define por la combinación de capas\r\n(layers), escalas (scales), coordenadas\r\n(coords) y facetas (facets). Adicionalmente a\r\nestos componentes se pueden aplicar temas (themes) que\r\npermiten controlar los detalles del diseño de la visualización.\r\nLayers\r\nLos layer se construyen con las funciones\r\ngeom_* y stat_* que veremos más adelante.\r\nConstan de 5 elementos:\r\ndata, set de datos (data.frame o\r\nsimilar) que contiene la información que se desea visualizar.\r\nmapping, elementos de mapeo definidos mediante\r\naes() para indicar la forma en que la las variables y\r\nobservaciones van a ser representadas en la visualización mediante\r\natributos estéticos (ejes, lineas, colores, rellenos, etc).\r\nstat, funciones estadísticas que resumen los datos\r\naplicando funciones estadísticas, e.g. promedio, agrupamiento y conteo\r\nde observaciones, o ajuste de un modelo lineal o suavizado,\r\netc.\r\ngeom, geometrías o formas que representan lo que\r\nrealmente se ve en un gráfico: puntos, líneas, polígonos, etc.\r\nposition, ajuste de posición de los elementos\r\ngeoms dentro de un layer para evitar su\r\nsuperposición.\r\nGeneralmente, sobre todo para gráficos simples, data y\r\nmapping se definen una vez para todo el gráfico dentro de\r\nla función ggplot(). En otras situaciones se hace a nivel\r\nde cada layer.\r\nScales\r\nAsignan los valores del espacio de datos a valores en el espacio de\r\nlos elementos estéticos (aesthetics o aes).\r\nPor ejemplo, el uso de un color, forma o tamaño de en un\r\ngeom puede ser controlado por un atributo de los datos. Las\r\nescalas también definen las leyenda y los ejes.\r\nCoordenadas\r\nSistema de coordendas (coord) que define que variables\r\ndefiniran el espacio del gráfico y como se representarán,\r\ne.g. coordanedas cartesianas, polares, etc.\r\nPaneles (facets)\r\nEs un elemento que permite especificar una o más variables para\r\ndividir el gráfico en paneles y así mostrar subgrupos de datos. Esto\r\npermite ver visualizar relaciones condicionales entre variables,\r\ne.g. y ~ x | z, es decir, que pasa con la variable\r\nx e y cuando cambia z.\r\nTemas\r\nAdicionalmente a estos componentes se pueden aplicar temas\r\n(themes) que permiten controlar los detalles del desieño de\r\nla visualización, tipografía, posición de algunos objetos, paleta de\r\ncolores, etc. Los valores predeterminados de ggplot2 son un\r\nbuen punto de partida pero exiten opciones predefinidas que pueden\r\nmodificarse para generar un tema particular. Otra fuente para consultar\r\nes el trabajo de Tufte\r\nPrimer gráfico paso a paso\r\nVeamos con un ejemplo como se combinan los componentes anteriormente\r\nvistos para realizar un gráfico simple. Para esto vamos a usar el set de\r\ndatos\r\npesada_novillos.xlsx\r\n\r\n\r\nnovillos <- readxl::read_excel(\"data/pesada_novillos.xlsx\")\r\n\r\n\r\n\r\nNuestro primer gráfico tendrá como objetivo mostrar la relación que\r\nexiste entre Peso_anterior y Peso (actual), y\r\npotencialmente ver si ésta es similar entre procedencias. Veamos paso\r\npor paso como se construye el gráfico.\r\nPrimero definimos el set de datos que usaremos:\r\n\r\n\r\nggplot(data = novillos)\r\n\r\n\r\n\r\n\r\nComo vemos esto no produjo nada ya que no indicamos cuales son las\r\nvariables que queremos graficar y cómo graficarlas. Nuestro\r\nlayer solo tiene la información de data.\r\nAgreguemos ahora la información de mappping usando\r\naes(). Usando el operador + podemos\r\nconcatenarlo al comando anterior.\r\n\r\n\r\nggplot(data = novillos) +\r\n  aes(x = Peso_inicial, y = Peso)\r\n\r\n\r\n\r\n\r\nAquí vemos que, si bien no hemos graficado nada, la información\r\nsuministrada permite a ggplot identificar los ejes, definir\r\nel espacio de coordanadas (cartesianas por defecto) y proponer unos\r\nlímites en función del rango de valores. Agreguemos ahora la geometría:\r\nen este caso tiene sentido usar geom_point() ya que\r\nqueremos mostrar un punto por observación\r\n\r\n\r\nggplot(data = novillos) +\r\n  aes(x = Peso_anterior, y = Peso) +\r\n  geom_point()\r\n\r\n\r\n\r\n\r\nComo vemos ahora el gráfico va tomando forma. Este tipo de gráficos\r\nse llama gráfico de dispersión y muestra la relación entre\r\nambas variables. Por defecto no se aplica ninguna transformación\r\nestadística lo que equivale a (stat = \"identity\").\r\nA este gráfico vamos a agregarle alguna función que permita resumir\r\nla relación entre ambas variables, por ejemplo un modelo de regresión.\r\nLa mejor forma de representarlo sería una línea. Para eso vamos a\r\nagregar otro layer con geom_line() donde\r\nindicaremos una transformación de los datos\r\nstat = smooth.\r\n\r\n\r\nggplot(data = novillos) +\r\n  aes(x = Peso_anterior, y = Peso) +\r\n  geom_point() +\r\n  geom_line(stat = 'smooth', method = 'lm')\r\n\r\n\r\n\r\n\r\nHay una relación positiva para todo el set de datos pero puede\r\nenmascarar algun patrón por Procedencia. Esta información\r\nla podemos agregar con otros atributos estéticos como por ejemplo\r\ncolor:\r\n\r\n\r\nggplot(data = novillos) +\r\n  aes(x = Peso_anterior, y = Peso, color = Procedencia) +\r\n  geom_point() +\r\n  geom_line(stat = 'smooth', method = 'lm')\r\n\r\n\r\n\r\n\r\nDe este gráfico surge que la relación en todos los casos es positiva\r\npero varia un poco según procedencia.\r\nDependiendo el tipo de geom tenemos distintos atributos\r\nestéticos para explorar: color y alpha\r\n(transparencia) para todos, shape y size para\r\npuntos, linewidth y linetype para lineas, y\r\nfill para barras, etc. Que tipo de atributo estético\r\ndepende también de la naturaleza de la variable: continua o discreta.\r\nVeamos como queda mapear los valores de Procedencia al\r\natributo shape (forma):\r\n\r\n\r\nggplot(data = novillos) +\r\n  aes(x = Peso_anterior, y = Peso, shape = Procedencia) +\r\n  geom_point() +\r\n  geom_line(stat = 'smooth', method = 'lm')\r\n\r\n\r\n\r\n\r\nLas estéticas se pueden combinar para mostrar mas relaciones entre\r\nvariables. Por ejemplo, además de shape = Procedencia\r\npodríamos agregar la información de los pesos iniciales como color:\r\n\r\n\r\nggplot(data = novillos) +\r\n  aes(x = Peso_anterior, y = Peso, shape = Procedencia, \r\n      color = Peso_inicial) +\r\n  geom_point() +\r\n  geom_line(aes(group = Procedencia), stat = \"smooth\", method = \"lm\")\r\n\r\n\r\n\r\n\r\nClaramente esto es una exageración pero muestra la potencialiadad de\r\nggplot2. Siempre tener en cuenta balance entre simplicidad\r\ndel gráfico y la cantidad de información que queremos comunicar.\r\nFinalmente vamos a ver como mejorar los nombres de los ejes, leyendas\r\ny agregar un título. Esto lo hacemos con labs(). Tambien\r\nagregamos algun tema predefinido ocomo theme_bw().\r\n\r\n\r\nggplot(data = novillos) +\r\n  aes(x = Peso_anterior, y = Peso, color = Procedencia) +\r\n  geom_point() +\r\n  geom_line(stat = \"smooth\", method = \"lm\") +\r\n  labs(x = \"Peso anterior (kg)\", y = \"Peso actual (kg)\",\r\n       color = \"Procedencia\", title = \"Relación peso anterior y actual\") +\r\n  theme_bw()\r\n\r\n\r\n\r\n\r\nGráficos\r\ncondicionales o por paneles: facets\r\nA veces es util mostrar los subgrupos en gráficos individuales o\r\npaneles. Esto se hace facilmente usando una o más variables\r\ncondicionales con facets. Este tipo de gráficos también se\r\ndenomian graficos condicionales ya que muestran la relacion de al menos\r\ndos variables de interés a través de los niveles de una tercera\r\nvariable: y ~ x | z.\r\nPor ejemplo, en el primer gráfico vimos como mostrar la relación\r\nentre los pesos y las procedencias como color. Eventualmente, ese\r\ngráfico podria dividirse en 4 paneles (uno por procedencia) y mostrar en\r\ncada uno el subconjunto de puntos.\r\n\r\n\r\nggplot(data = novillos) +\r\n  aes(x = Peso_anterior, y = Peso) +\r\n  geom_point() +\r\n  geom_line(stat = 'smooth', method = 'lm') +\r\n  facet_wrap(~ Procedencia)\r\n\r\n\r\n\r\n\r\nHay dos tipos de facetado: facet_wrap() y\r\nfacet_grid(). El primero permite agregar una o mas\r\nvariables condicionales pero cada subpanel se muestra secuencialmente.\r\nFunciona bien cuando tenemos una sola variable para dividir los subplots\r\no pocos niveles en la combinación. La forma de indicar la variable es\r\n~ variable.\r\nEn cambio, facet_grid() permite organizar los subplots\r\nen filas y columnas. Las varialbes se indican en este orden\r\nfila ~ columna. Para este ejemplo vamos a usar la variable\r\nTropa:\r\n\r\n\r\nggplot(data = novillos) +\r\n  aes(x = Peso_anterior, y = Peso) +\r\n  geom_point() +\r\n  geom_line(stat = 'smooth', method = 'lm') +\r\n  facet_grid(Tropa ~ Procedencia)\r\n\r\n\r\n\r\n\r\nPor defecto los subplots o facets tienen escalas iguales\r\nen ambos ejes para comparar. A veces conviene dejar una o las dos\r\nescalas variar libremente, esto se hace con el argumento\r\nscales y las palabras clave 'free_y',\r\n'free_x' o 'free' (ambas a la vez).\r\n\r\n\r\nggplot(data = novillos) +\r\n  aes(x = Peso_anterior, y = Peso) +\r\n  geom_point() +\r\n  geom_line(stat = 'smooth', method = 'lm') +\r\n  facet_grid(Tropa ~ Procedencia, scales = \"free\")\r\n\r\n\r\n\r\n\r\nOtra aspecto importante en la visualización usando facets es el texto\r\nque identifica cada panales. Esto depende de como estan configurados los\r\ndatos y se controla con el argument labeller. Por defecto\r\nse toma el valor del factor que se usa para definir los grupos. En\r\nalgunos casos conviene incluir el nombres de la variable.\r\n\r\n\r\nggplot(data = novillos) +\r\n  aes(x = Peso_anterior, y = Peso) +\r\n  geom_point() +\r\n  geom_line(stat = 'smooth', method = 'lm') +\r\n  facet_grid(Tropa ~ Procedencia, scales = \"free\", labeller = label_both)\r\n\r\n\r\n\r\n\r\nTemas\r\nLos temas en ggplot hacen referencia al control fino de\r\nla posición, el aspecto, y las formas de los distintos componentes del\r\ngráfico. El listado de componentes que se pueden modificar en un tema se\r\nincluyen en ?theme(). Como vemos la lista es larga ya que\r\ncada aspecto del gráfico puede controlarse permitiendo crear nuestros\r\npropios temas.\r\nggplot2 algunos temas predefinidos. Por defecto los\r\ngráficos utilizan un tema llamado theme_gray() que tiene\r\nuna seleccion de parámetros elegante y que sirve para la mayoría de los\r\ncasos. Existen otros temas específicos que puden ser un punto de partida\r\npara hacer modificaciones extra.\r\nPor ejemplo, el tema them_bw() remueve el fondo gris\r\npero si queremos quitar la grilla podemos hacer:\r\n\r\n\r\n# Modificar el tema\r\nmi_tema <- theme_bw() + theme(panel.grid = element_blank())\r\n\r\n# Aplicar nuestro nuevo tema.\r\nggplot(data = novillos) +\r\n  aes(x = Peso_anterior, y = Peso, color = Procedencia) +\r\n  geom_point() +\r\n  geom_line(stat = 'smooth', method = 'lm') +\r\n  mi_tema\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-27T15:00:14-03:00"
    },
    {
      "path": "primera_sesion.html",
      "title": "Primera sesion en R y RStudio",
      "author": [],
      "contents": "\r\n\r\nContents\r\nLa consola\r\nEl script\r\nAyuda!!!\r\n\r\nEl entorno de trabajo de RStudio se divide en cuatro\r\npaneles. La disposición y contenido de los 4 paneles se puede\r\npersonalizar yendo a View > Panes > Panes Layout....\r\nA continuación la descripción de los paneles por defecto.\r\n\r\n\r\n\r\nFigure 1: Interfase principal de RStudio\r\n\r\n\r\n\r\nEditor. Es donde se editan los scripts\r\nque son archivos de texto plano con los comandos para ejecutar en\r\nR. Este panel no aparece a menos que se cree un nuevo\r\nscript o se abra uno previamente guardado.\r\nConsole (consola). Es donde vive\r\nR propiamente dicho. Allí se ejecutan los comandos y se\r\nobtienen las salidas de R.\r\nEnvironmnet/History/Connections. En la primera\r\npestaña se visualizan los objetos (variables, funciones o datos\r\ncargados) que están disponibles en el entorno de R,\r\ni.e. en la memoria. En la segunda se puede ver el historial de comandos\r\ningresados o enviados a la consola. La tercera pestaña visualiza las\r\nconexiones establecidas con diferentes base de datos.\r\nFiles/Plots/Packages/Help/Viewer. Allí se puede\r\nmanejar los archivos del directorio de trabajo, visualizar los gráficos\r\ngenerados en R con posibilidad de exportarlos en varios\r\nformatos, administrar los paquetes o complementos, buscar o explorar el\r\nmanual de ayuda y previsualizar archivos HTML.\r\nLa consola\r\nLa línea de comandos o consola es el modo\r\ninteractivo mediante el cual podemos ejecutar comandos directamente en\r\nel intérprete de R. El símbolo o prompt\r\n> indica que R está disponible\r\nesperando una orden. Si la orden no está completa el símbolo se\r\ntransforma en +. Por ejemplo: si tipeamos\r\n2 + 2 y luego ENTER:\r\n\r\n\r\n2 + 2\r\n\r\n\r\n[1] 4\r\n\r\nObetenemos inmediatemente el resultado. Otro ejemplo: el promedio de\r\nlos números 1, 3 y 4\r\n\r\n\r\n(1 + 3 + 4) / 3\r\n\r\n\r\n[1] 2.666667\r\n\r\nEl script\r\nEl editor de scripts (panel #1) es un editor de\r\ntexto plano que está conectado con la consola (panel #2). Tiene algunas\r\nfuncionalidades que facilitan la edición del código:\r\nResaltado sintaxis: mediante colores resalta las funciones,\r\nvariables, comandos o palabras claves del lenguaje\r\nR\r\nSangrado automático: agrega espacios en blanco para mantener la\r\nsangría de los bloques de código.\r\nPlegado de código: permite colapsar bloques de código\r\nCompletado automático y ayuda en linea: muestra sugerencias para\r\ncompletar el comando o argumentos usando la tecla TAB.\r\nPara crear un nuevo script se puede usar uno de los siguientes\r\nmétodos:\r\nIr a al menu File > New File > R Script\r\nUsar el atajo de teclado CTRL + SHIFT + N\r\nClickear en el primer ícono de la barra de menu\r\n\r\n\r\n\r\nFigure 2: Barra de herramientas de RStudio\r\n\r\n\r\n\r\nUna vez abierto el script en blanco, se pueden empezar a escribir los\r\ncomandos de R. Por ejemplo podemos escribir lo\r\nsiguiente:\r\n\r\n\r\n\"Hola Mundo!\" # Clásico mensaje \"Hola mundo!\"\r\n\r\n# Calcular el promedio de estos números\r\n(1 + 3 + 4) / 3\r\n\r\n\r\n\r\nEstos comandos no se van a ejecutar automáticamente ya que solo los\r\nhemos escritor en el script. Para ejecutar estos comandos en la consola\r\nhay que posicionar le cursor en la linea deseada o bien seleccionar si\r\nqueremos ejecutar varias a la vez y luego enviarlo a la consoloa con una\r\nde las siguientes opciones:\r\nIr al menu Code > Run Selected Line(s)\r\nUsar el atajo de teclado CTRL + ENTER o\r\nCTRL + R\r\nUsar el ícono Run de la barra de herramientas de la\r\npestaña del script\r\n\r\n\r\n\r\nFigure 3: Barra de herramientas del panel Editor\r\n\r\n\r\n\r\nEl simbolo # indica que lo que sigue es un\r\ncomentario y por lo tanto R lo ignora\r\ncuando es enviado a la consola. Los comentarios pueden ir solos en una\r\nlínea separada o bien dentro de una línea que tenga algún comando. Si\r\nbien no son necesarios para correr el código, los comentarios son muy\r\nútiles para estructurar el script y hacer anotaciones para que otros, o\r\nnosotros en un futuro, entiendan lo que hace esa parte del script.\r\nPara guardar el script:\r\nIr al menu File > Save o usar el atajo de teclado\r\nCTRL + S o bien el ícono con el diskette de la barra de\r\nherramientas global o de la pestaña del script activo.\r\nElegir la carpeta destino y el nombre de archivo. Automáticamente\r\nse agregará la extensión .R que corresponde a los\r\nscripts.\r\nAyuda!!!\r\nPor último, y no menos importante, R y\r\nRStudio cuentan con un completo sistema de ayuda. Desde\r\nla consola se puede acceder usando la función ? seguida del\r\nnombre de la función o bien help(\"nombre\")\r\n\r\n\r\n# Pedir ayuda de la función mean\r\n?mean\r\nhelp(mean)\r\n\r\n\r\n\r\nUna de las ventajas de RStudio es que dispone de un\r\npanel (Panel #4) dedicado a visualizar las páginas de ayuda. Allí se\r\npuede navegar por las páginas utilizando los links, realizar búsquedas,\r\netc. Leer la documentación nunca viene mal y generalmente ahorra dolores\r\nde cabeza.\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-27T15:00:14-03:00"
    },
    {
      "path": "R_basico.html",
      "title": "¿Cómo es el lenguaje R?",
      "author": [],
      "contents": "\r\n\r\nContents\r\nOperadores matemáticos y\r\nlógicos\r\nVariables y objetos\r\nTipos de datos\r\nEstructura de datos\r\n\r\nR es un lenguaje de programación orientado al\r\nanálisis estadístico. Como todo lenguaje tiene sus particularidades. A\r\ncontinuación vamos a ver algunos aspectos básicos de dicho lenguaje que\r\nnos permitirá avanzar con las funciones que vamos a usar para analizar\r\ndatos.\r\nOperadores matemáticos y\r\nlógicos\r\nLas operaciones matemáticas básicas se realizan usando los símbolos\r\nconvencionales: suma (+), resta (-), división\r\n(/), producto (*) y potencia\r\n(^)\r\nPor ejemplo, \\(1 + \\left( 3 \\times 4 +\r\n\\dfrac{5 -2}{3} \\right)^2\\) en R es:\r\n\r\n\r\n1 + (3 * 4 + (5 - 2)/3)^2\r\n\r\n\r\n[1] 170\r\n\r\nTambién se pueden evaluar expresiones lógicas: igual\r\n(==), distinto (!=), mayor que\r\n(>), menor que (<), mayor o igual que\r\n(>=), menor o igual que (<=). El\r\nresultado es TRUE (verdadero) o FALSE\r\n(falso).\r\nPor ejemplo, podemos evaluar si 3 es igual 4\r\n\r\n\r\n3 == 4\r\n\r\n\r\n[1] FALSE\r\n\r\nO si 5 es mayor o igual a 3\r\n\r\n\r\n5 >= 3\r\n\r\n\r\n[1] TRUE\r\n\r\nTambién se pueden combinar con los operadores intersección\r\n(&), unión (|) y\r\nnegación (!).\r\nPor ejemplo, evaluar si se cumplen las dos cosas anteriores a la\r\nvez\r\n\r\n\r\n3 == 4 & 5 >= 3\r\n\r\n\r\n[1] FALSE\r\n\r\nDevuelve FALSE porque 3 == 4 no es\r\nverdadero. Si reemplazamos & por | va a\r\ndevolver evaluar si una de las dos se cumple:\r\n\r\n\r\n3 == 4 | 5 >= 3\r\n\r\n\r\n[1] TRUE\r\n\r\nTambien se pueden combinar con operaciones matemáticas…\r\n\r\n\r\n4 * 2 == 8\r\n\r\n\r\n[1] TRUE\r\n\r\nEn este caso primero evalúa 4 * 2 y luego compara el\r\nresultado con 8\r\nVariables y objetos\r\nUn objeto es un espacio de la memoria que almacena un pedazo de\r\ninformación (una cifra, un conjunto de números, el resultado de un\r\nanálisis, etc). También se denomina variables ya que su\r\ncontenido puede cambiar. En R prácticamente todo puede\r\nrepresentarse como un objeto.\r\nLos objetos o variables se crean asignandoles informacicon\r\n(números, letras, resultados de operaciones, etc), con el símbolo\r\n<- (ALT + -) o =. Esta\r\ninformacion se puede recuperar, modificar o utilizar para otros\r\ncálculos.\r\nSupongamos que queremos asignar el valor 2 a la variable\r\nx.\r\n\r\n\r\nx <- 2\r\n\r\n\r\n\r\nEn la consola vuelve a aparecer el simbolo > y nada\r\nmás. En el ambiente se ve una entrada que dice x y el\r\nvalor. Podemos recuperar el valor en la consola tipeando el nombre del\r\nobjeto:\r\n\r\n\r\nx\r\n\r\n\r\n[1] 2\r\n\r\nTambien podemos reusarlo en otro calculo, por ejemplo obtener 2 veces\r\nx.\r\n\r\n\r\n2 * x\r\n\r\n\r\n[1] 4\r\n\r\nO bien obtener una nueva variable\r\n\r\n\r\ny <- 2 * x +1\r\ny\r\n\r\n\r\n[1] 5\r\n\r\nAclaración\r\n:\r\nlos nombres de las variables no deben empezar con números ni contener\r\nespacios. No pueden usarse operadores (*+-/&%) en los\r\nnombres pero puede usarse . o _.\r\n\r\n# Mal\r\n2x <- 3\r\nmi variable <- 3\r\n\r\n# Bien\r\nx_2 <- 3\r\nx.2 <- 3\r\nx2 <- 3\r\n\r\nTambién R es sensibles a mayúsculas\r\n\r\n\r\n# Definir 'A' y 'a'\r\nA <- 3\r\na <- 5\r\n\r\n# Verificar si 'A' y 'a' son lo mismo\r\nA == a\r\n\r\n\r\n[1] FALSE\r\n\r\nVectores\r\nSon los objetos más simples a partir de los cuales se construyen\r\notros tipos de objetos. Se crean utilizando la función c()\r\n(combine) para “combinar” datos del mismo\r\ntipo\r\n\r\n\r\nx <- c(13, 45, 67, 45)\r\nx\r\n\r\n\r\n[1] 13 45 67 45\r\n\r\nEn el caso de mezclar de datos, R los va a\r\nconvertir al tipo de datos más simple.\r\nPor ejemplo: si queremos crear un vector con 3 valores: lógico,\r\nnumérico y texto, R va a asumir que todos los elementos\r\nson de tipo texto\r\n\r\n\r\ny <- c(TRUE, 34, \"hola\")\r\ny\r\n\r\n\r\n[1] \"TRUE\" \"34\"   \"hola\"\r\n\r\nLos vectores están indexados. Se puede acceder a sus elementos usando\r\nel operador [ ] e indicando el número de orden.\r\nPor ejemplo: para recuperar el 3er elemento del vector\r\nx\r\n\r\n\r\ny[3]\r\n\r\n\r\n[1] \"hola\"\r\n\r\nVeremos más adelante los distintos tipos.\r\nFunciones y argumentos\r\nPara crear los vectores utilizamos una funcion c(). Las\r\nfunciones dentro de R tienen la siguiente forma\r\nnombre_funcion(arg1, arg2, ...)\r\ndonde arg son los argumentos (valores de entrada u\r\nopciones). Algunos argumentos toman valores por defecto otros hay que\r\ndeclararlos.\r\nPor ejemplo, la función round()` tiene los\r\nargumentos:\r\nx, para pasar el número o vector numérico que queremos\r\nredondear\r\ndigits = 0 para indicar el numero de dígitos a usar,\r\npor defecto 0.\r\nSupongamos que queremos redondear el numero 3.141593 a 3\r\ndígitos.\r\n\r\n\r\n# Indicando los argumentos\r\nround(x = 3.141593, digits = 3)\r\n\r\n\r\n[1] 3.142\r\n\r\n# Sin indicar los argumentos\r\nround(3.141593, 3)\r\n\r\n\r\n[1] 3.142\r\n\r\nEn este último caso, el orden de los argumentos es clave ya que\r\nR asigna los valores en función de la posición.\r\n\r\n\r\n# Sin indicar los argumentos\r\nround(3, 3.141593)\r\n\r\n\r\n[1] 3\r\n\r\nDevuelve 3 por considera que queremos redondear el\r\nnúmero 3\r\nTipos de datos\r\nNuméricos (numeric)\r\nNúmeros racionales (enteros o con coma).\r\n\r\n\r\nx <- c(3, 4, 5)\r\nclass(x)\r\n\r\n\r\n[1] \"numeric\"\r\n\r\nLos números enteros se tratan como numeric a menos que\r\nse los convierta con as.integer().\r\n\r\n\r\ny <- as.integer(x)\r\nclass(y)\r\n\r\n\r\n[1] \"integer\"\r\n\r\nLos datos numéricos permiten todas las operaciones algebráicas\r\n\r\n\r\nmean(x)\r\n\r\n\r\n[1] 4\r\n\r\nmean(y)\r\n\r\n\r\n[1] 4\r\n\r\nTexto (character)\r\nCadenas de texto o número delimitadas por comillas (simples o dobles,\r\nnom mezclar).\r\n\r\n\r\nx <- c(\"hola\", '3')\r\nclass(x)\r\n\r\n\r\n[1] \"character\"\r\n\r\nLógicamente no se pueden realizar operaciones numéricas.\r\nR avisa y devuelve NA\r\n\r\n\r\nmean(x)\r\n\r\n\r\n[1] NA\r\n\r\nLógicos (logic)\r\nCondición verdadero (TRUE o T) o falso\r\n(FALSE o F)\r\n\r\n\r\nlogico <- c(T, F, T, TRUE, FALSE, F)\r\nlogico\r\n\r\n\r\n[1]  TRUE FALSE  TRUE  TRUE FALSE FALSE\r\n\r\nOtro ejemplo: ¿cuáles de los siguientes números son mayores a 30?\r\n\r\n\r\nx <- c(23, 43, 21, 34, 56, 3, 23, 3)\r\nx > 30\r\n\r\n\r\n[1] FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE\r\n\r\nOtros tipos de datos\r\nLos valores faltantes se simbolizan en R con\r\nNA (not available). Indican que debería haber un\r\nvalor pero que está faltando.\r\n\r\n\r\nx <- c(1, 2, 3, NA, 4)\r\nis.na(x)\r\n\r\n\r\n[1] FALSE FALSE FALSE  TRUE FALSE\r\n\r\nA diferencia del NA, un valor de tipo NULL\r\nindica que no hay información y que tampoco se esperaba que la haya.\r\n\r\n\r\nx <- c(1, 2, 3, NULL, 4)\r\nx\r\n\r\n\r\n[1] 1 2 3 4\r\n\r\nAlgunas operaciones matemáticas devuelven valores NaN\r\n(not a number) cuando no están definidas, por ejemplo:\r\n\r\n\r\n0/0\r\n\r\n\r\n[1] NaN\r\n\r\nO bien valores infinitos (Inf):\r\n\r\n\r\n1/0\r\n\r\n\r\n[1] Inf\r\n\r\nEstructura de datos\r\nMatriz (matrix)\r\nColección de vectores de igual longitud y mismo tipo de\r\ndatos. Se crea con la función matrix(), o combinando\r\nfilas o columnas de igual longitud con rbind() o\r\ncbind().\r\nPor ejemplo la matriz:\r\n\\[\r\n\\mathbf{M} = \\left[\\begin{array}{c c}\r\n1 & 2 \\\\\r\n3 & 4 \\\\\r\n5 & 6 \\\\\r\n\\end{array} \\right]\r\n\\] en R se representa así:\r\n\r\n\r\nM <- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2)\r\nM\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    4\r\n[2,]    2    5\r\n[3,]    3    6\r\n\r\nSe puede indexar usando [n, p] donde n es\r\nel numero de fila y p numero de columna. Por ejemplo para\r\nobtener el elemento \\(m_{12}\\)\r\n\r\n\r\nM[1,2]\r\n\r\n\r\n[1] 4\r\n\r\nO todos los elementos de la columna 2\r\n\r\n\r\nM[, 2]\r\n\r\n\r\n[1] 4 5 6\r\n\r\nListas (list)\r\nEs una generalización de los vectores ya que los elementos pueden\r\nser de igual o diferente tipo de datos\r\n\r\n\r\nlst <- list(23, \"hola\", TRUE)\r\nlst\r\n\r\n\r\n[[1]]\r\n[1] 23\r\n\r\n[[2]]\r\n[1] \"hola\"\r\n\r\n[[3]]\r\n[1] TRUE\r\n\r\nSe pueden indexar usando [[ ]]\r\n\r\n\r\n# El segundo elemento de l\r\nlst[[2]]\r\n\r\n\r\n[1] \"hola\"\r\n\r\nCada elemento a su vez puede ser cualquier objeto de los vistos\r\nanteriormente.\r\nHoja de datos\r\n(data.frame)\r\nSimilares a las matrices pero cada columna puede ser de un tipo de\r\ndato diferente. Útil para guardar datos donde cada fila es un caso y\r\ncada columna una variable.\r\nSupongamos que tenemos la tabla de datos:\r\nLote\r\nVariedad\r\nRendimiento\r\n1\r\nEscorpion\r\n34\r\n2\r\nEscorpion\r\n36\r\n3\r\nYarara\r\n40\r\n4\r\nBaguette11\r\n28\r\n5\r\nTijetera\r\n31\r\nEn R podemos representarla así:\r\n\r\n\r\ntrigo <- data.frame(\r\n  lote = 1:5,\r\n  variedad = c('Escorpion', 'Escorpion', 'Yarara', 'Baguette 11', 'Tijetera'),\r\n  rendimiento = c(34, 36, 40, 28, 31)\r\n)\r\ntrigo\r\n\r\n\r\n  lote    variedad rendimiento\r\n1    1   Escorpion          34\r\n2    2   Escorpion          36\r\n3    3      Yarara          40\r\n4    4 Baguette 11          28\r\n5    5    Tijetera          31\r\n\r\nAl igual que las matrices, un data.frame se puede\r\nindexar con [ ]. Por ejemplo, si quisieramos El bombre de\r\nla varidedad de la fila 2\r\n\r\n\r\ntrigo[2, 3]\r\n\r\n\r\n[1] 36\r\n\r\nO todos los nombres de la fila 2\r\n\r\n\r\ntrigo[2, ]\r\n\r\n\r\n  lote  variedad rendimiento\r\n2    2 Escorpion          36\r\n\r\nTambien podemos hacer consultas más específicas: “Lotes con\r\nrendimiento mayor a 35 qq/ha”\r\n\r\n\r\ntrigo[trigo$rendimiento > 35, ]\r\n\r\n\r\n  lote  variedad rendimiento\r\n2    2 Escorpion          36\r\n3    3    Yarara          40\r\n\r\nLas variables o columnas se pueden acceder individualmente usando o\r\nel operador $ seguido dle nombre de la columna o\r\n[, \"nombre\"], o [, posicion]. Ejemplo: extraer\r\nla columna rendimiento que es la número 3\r\n\r\n\r\ntrigo$rendimiento\r\n\r\n\r\n[1] 34 36 40 28 31\r\n\r\ntrigo[, \"rendimiento\"]\r\n\r\n\r\n[1] 34 36 40 28 31\r\n\r\ntrigo[, 3]\r\n\r\n\r\n[1] 34 36 40 28 31\r\n\r\nFactores (factor y\r\nordered)\r\nSi los elementos de vector de tipo texto (character) y\r\nrepresentan niveles nominales (categorías), el objeto puede convertirse\r\na factor de modo tal que los valores son reemplazados por\r\nun número que se asocia a los niveles del factor (ordenados\r\nalfabeticamente, a menos que se indique otra cosa).\r\nUn ejemplo de un vector tipo character.\r\n\r\n\r\nx <- c('bajo', 'medio', 'alto', 'alto', 'bajo', 'bajo')\r\nx\r\n\r\n\r\n[1] \"bajo\"  \"medio\" \"alto\"  \"alto\"  \"bajo\"  \"bajo\" \r\n\r\nSólo se muestran los valores (bajo, medio y\r\nalto). No hay información de niveles. Ahora si aplicamos\r\nfactor(x):\r\n\r\n\r\ny <- factor(x)\r\ny\r\n\r\n\r\n[1] bajo  medio alto  alto  bajo  bajo \r\nLevels: alto bajo medio\r\n\r\nLos valores pasaron al atributo levels y los datos\r\nfueron reemplazados por los identificadores 2,\r\n3, y 1 según el orden alfabético de los\r\nniveles.\r\n\r\n\r\nas.numeric(y)\r\n\r\n\r\n[1] 2 3 1 1 2 2\r\n\r\nCuando los niveles tienen una jerarquía u orden, se puede especificar\r\neste tipo de relación mediante as.ordered() que convierte\r\nel factor en uno especial ordered agregando la\r\nrelación entre los niveles\r\n\r\n\r\nz <- factor(x, levels = c('bajo', 'medio', 'alto'))\r\nz <- as.ordered(z)\r\nz\r\n\r\n\r\n[1] bajo  medio alto  alto  bajo  bajo \r\nLevels: bajo < medio < alto\r\n\r\nLos factores como cualquier vector tambien se indexan con\r\n[ ].\r\n\r\n\r\n\r\n",
      "last_modified": "2022-08-27T15:00:14-03:00"
    }
  ],
  "collections": []
}
